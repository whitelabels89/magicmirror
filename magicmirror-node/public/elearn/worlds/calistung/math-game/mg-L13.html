<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8" />
  <title>Math Game L13 ‚Äì Neon Catch</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="/elearn/worlds/calistung/math-game/mathgame-shell.css" />
  <style>
    .neon-stage {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      text-align: center;
    }

    .neon-stage h2 {
      margin: 0;
      font-family: "Baloo 2", "Nunito", sans-serif;
      font-size: 26px;
      letter-spacing: .5px;
      color: rgba(15, 23, 42, 0.86);
    }

    .neon-stage__question {
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: clamp(22px, 3.6vw, 34px);
      font-weight: 800;
      letter-spacing: .35px;
      color: #6ef7ff;
      text-shadow: 0 0 18px rgba(0, 255, 224, 0.45);
      min-height: 46px;
    }

    .neon-stage__question strong {
      font: inherit;
    }

    .neon-stage__stats {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      margin-top: 4px;
    }

    .neon-stage__stats .shell-pill {
      background: rgba(12, 18, 35, 0.9);
      color: #cfefff;
      border: 1px solid rgba(122, 124, 251, 0.38);
      box-shadow: 0 6px 16px rgba(12, 18, 45, 0.18);
      padding: 5px 12px;
      font-size: 0.85rem;
    }

    .neon-stage__stats .shell-pill strong,
    .neon-stage__stats .shell-pill span {
      color: inherit;
      font-size: 0.9rem;
    }

    .neon-stage__start {
      display: flex;
      justify-content: center;
      margin-top: 8px;
    }

    .neon-stage__start .shell-button {
      min-width: 160px;
    }

    canvas {
      width: min(96vw, 960px);
      height: clamp(420px, 62vh, 640px);
      aspect-ratio: 16/10;
      border: 2px solid rgba(122,124,251,0.35);
      border-radius: 18px;
      background: #081016;
      box-shadow: 0 22px 46px rgba(9, 10, 20, 0.32);
      touch-action: none;
    }

    .touchpad {
      display: grid;
      grid-template-columns: repeat(3, min(120px, 28vw));
      gap: 8px;
      justify-content: center;
      margin-bottom: 6px;
    }

    .pad {
      border: 1px solid rgba(158,255,0,.4);
      background: linear-gradient(180deg, rgba(158,255,0,.18), rgba(40,55,0,.25));
      color: #e9ffd6;
      padding: 10px;
      border-radius: 12px;
      font-weight: 700;
      cursor: pointer;
      user-select: none;
      touch-action: none;
    }

    .footer-note {
      margin: 6px 0 12px;
      color: #83a6b3;
      font-size: 12px;
    }
  </style>
  <link rel="stylesheet" href="/elearn/worlds/calistung/buttons.css" />
</head>
<body class="mathgame-shell theme-neon" data-nav-badge="Calistung Math" data-nav-home-url="/elearn/worlds/calistung/index.html">
  <div class="shell-wrapper">
    <header class="shell-header">
      <div class="shell-header__title">
        <span class="shell-badge">Level 13</span>
        <h1 class="shell-title">Neon Catch</h1>
        <p class="shell-subtitle">Gerakkan hovercraft, tangkap chip angka yang benar, dan naik level tanpa kehilangan nyawa.</p>
      </div>
      <div class="shell-hud">
        <div class="shell-pill">
          <span class="shell-pill-label">Skor</span>
          <span class="shell-pill-value" data-hud-value="score">0</span>
        </div>
        <div class="shell-pill">
          <span class="shell-pill-label">Level</span>
          <span class="shell-pill-value" data-hud-value="level">1</span>
        </div>
        <div class="shell-pill">
          <span class="shell-pill-label">Nyawa</span>
          <span class="shell-pill-value" data-hud-value="lives">‚ù§‚ù§‚ù§</span>
        </div>
      </div>
    </header>

    <section class="mission-card">
      <h2>üéØ Misimu</h2>
      <p data-mission-text>Arahkan hovercraft ke chip angka yang hasilnya benar. Tangkap semua jawaban tepat untuk naik level!</p>
    </section>

    <main class="mathgame-stage">
      <section class="stage-card stage-card--contrast neon-stage">
        <h2>Neon Catch Arena</h2>
        <div class="neon-stage__question" aria-live="polite"><strong id="question">Siap?</strong></div>
        <div class="neon-stage__stats" aria-live="polite">
          <div class="shell-pill">Skor: <strong id="score">0</strong></div>
          <div class="shell-pill">Level: <strong id="level">1</strong></div>
          <div class="shell-pill">Nyawa: <strong id="lives">‚ù§‚ù§‚ù§</strong></div>
        </div>
        <div class="neon-stage__start" id="startControls">
          <button id="btnStartGame" class="shell-button" type="button">Mulai</button>
        </div>
        <canvas id="game" width="900" height="560" aria-label="Neon Catch Math Game"></canvas>
        <div class="touchpad" aria-hidden="false">
          <div class="pad" id="left">‚óÄÔ∏é</div>
          <div class="pad" id="drop">‚ñº</div>
          <div class="pad" id="right">‚ñ∂Ô∏é</div>
        </div>
        <p class="footer-note">Gerakkan hovercraft dengan ‚óÄÔ∏é ‚ñ∂Ô∏é atau sentuh. Arahkan tepat di bawah chip angka yang benar.</p>
      </section>
    </main>

    <section class="shell-action-bar" aria-label="Kontrol aksi">
      <button id="btnNew" class="shell-button" type="button">üîÑ Acak Soal</button>
      <button id="btnPause" class="shell-button secondary" type="button">‚è∏Ô∏è Pause</button>
      <button id="btnReset" class="shell-button ghost" type="button">‚Ü∫ Reset</button>
      <button id="btnSelesai" class="shell-button ghost" type="button">Selesai</button>
    </section>

    <aside class="buddy-widget" aria-label="Teman penyemangat">
      <div class="buddy-avatar" data-buddy-emoji aria-hidden="true">üõ∏</div>
      <div class="buddy-dialog" data-buddy-dialog>Gerakkan hovercraft, tangkap chip yang tepat, dan hindari jawaban salah!</div>
    </aside>
  </div>
  <script src="/elearn/worlds/calistung/math-game/mathgame-shell.js"></script>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const qEl = document.getElementById('question');
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const livesEl = document.getElementById('lives');
    const btnNew = document.getElementById('btnNew');
    const btnPause = document.getElementById('btnPause');
    const btnReset = document.getElementById('btnReset');
    const btnStartGame = document.getElementById('btnStartGame');
    const leftBtn = document.getElementById('left');
    const rightBtn = document.getElementById('right');
    const dropBtn = document.getElementById('drop');

    const hudScoreEl = document.querySelector('[data-hud-value="score"]');
    const hudLevelEl = document.querySelector('[data-hud-value="level"]');
    const hudLivesEl = document.querySelector('[data-hud-value="lives"]');
    const buddyEmojiEl = document.querySelector('[data-buddy-emoji]');
    const buddyDialogEl = document.querySelector('[data-buddy-dialog]');

    const maxLives = 3;

    let running = false;
    let score = 0;
    let level = 1;
    let lives = maxLives;
    let animationId = null;

    const CW = () => canvas.clientWidth;
    const CH = () => canvas.clientHeight;

    function setBuddy(emoji, text){
      if(buddyEmojiEl && emoji){ buddyEmojiEl.textContent = emoji; }
      if(buddyDialogEl && text){ buddyDialogEl.textContent = text; }
      if(window.mathgameShell && typeof window.mathgameShell.setBuddyMood === 'function'){
        window.mathgameShell.setBuddyMood(emoji, text);
      }
    }

    function livesString(){
      return '‚ù§'.repeat(lives) + '‚ô°'.repeat(maxLives - lives);
    }

    function syncHud(status = running ? 'Playing' : 'Paused'){
      if(hudScoreEl) hudScoreEl.textContent = score;
      if(hudLevelEl) hudLevelEl.textContent = level;
      if(hudLivesEl) hudLivesEl.textContent = livesString();
      if(window.mathgameShell && typeof window.mathgameShell.updateHud === 'function'){
        window.mathgameShell.updateHud({ score, level, lives: livesString(), status });
      }
    }

    const player = {
      x: CW() / 2,
      y: CH() - 80,
      w: 160,
      h: 26,
      speed: 7,
      vx: 0,
      vy: 0
    };

    const drops = [];
    let currentQ = null;

    function neonGridBackground() {
      const w = CW();
      const h = CH();
      const spacing = Math.max(36, Math.min(80, w / 12));
      ctx.save();
      ctx.fillStyle = '#081016';
      ctx.fillRect(0,0,w,h);
      ctx.strokeStyle = 'rgba(0,255,224,0.12)';
      ctx.lineWidth = 1;
      ctx.shadowColor = 'rgba(0,255,224,0.15)';
      ctx.shadowBlur = 4;
      for(let x = 0; x <= w; x += spacing){
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);
        ctx.stroke();
      }
      for(let y = 0; y <= h; y += spacing){
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
      }
      ctx.shadowBlur = 0;
      const grad = ctx.createLinearGradient(0, 0, 0, Math.min(220, h));
      grad.addColorStop(0, 'rgba(0, 255, 224, 0.24)');
      grad.addColorStop(1, 'rgba(0, 255, 224, 0)');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, w, Math.min(220, h));
      ctx.restore();
    }

    function randomInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

    function newQuestion() {
      const ops = level >= 3 ? ['+','-','√ó'] : ['+','-'];
      const op = ops[randomInt(0, ops.length-1)];
      let a = randomInt(1, 10);
      let b = randomInt(1, 10);
      if(op === '-' && b > a){ [a,b] = [b,a]; }
      if(op === '√ó'){ a = randomInt(2, 9); b = randomInt(2, 9); }
      const ans = (op === '+') ? a+b : (op === '-') ? a-b : a*b;
      const display = `${a} ${op} ${b}`;
      const wrong1 = ans + randomInt(1,3);
      const wrong2 = Math.max(0, ans - randomInt(1,3));
      const opts = [ans, wrong1, wrong2].sort(()=>Math.random()-0.5);
      currentQ = { text: display, answer: ans, options: opts };
      qEl.textContent = display;
      drops.length = 0;
      const lanes = [CW()*0.2, CW()*0.5, CW()*0.8];
      for(let i=0;i<opts.length;i++){
      const drop = {
        x: lanes[i] + randomInt(-30,30),
        y: -randomInt(40,160),
        r: 26,
        v: 1.6 + level*0.25 + Math.random()*0.55,
        value: opts[i],
        caught:false
      };
        drop.x = Math.max(drop.r + 6, Math.min(CW() - drop.r - 6, drop.x));
        drops.push(drop);
      }
      if(running){
        setBuddy('üõ∏', 'Tangkap chip dengan jawaban yang benar!');
        syncHud('Playing');
      } else {
        syncHud('Ready');
      }
    }

    function drawPlayer() {
      ctx.save();
      ctx.translate(player.x, player.y);
      ctx.save();
      ctx.globalAlpha = 0.55;
      const glow = ctx.createRadialGradient(0, 12, 6, 0, 12, 70);
      glow.addColorStop(0, 'rgba(0,255,224,.55)');
      glow.addColorStop(1, 'rgba(0,255,224,0)');
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.ellipse(0, 18, player.w*0.55, 14, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      const bodyGrad = ctx.createLinearGradient(0,-14,0,24);
      bodyGrad.addColorStop(0, 'rgba(0,255,224,.95)');
      bodyGrad.addColorStop(1, 'rgba(0,100,90,.65)');
      ctx.fillStyle = bodyGrad;
      roundedRect(-player.w/2, -player.h/2, player.w, player.h, 14);
      ctx.fill();
      ctx.shadowColor = 'rgba(0,255,224,.9)';
      ctx.shadowBlur = 22;
      ctx.lineWidth = 3;
      ctx.strokeStyle = 'rgba(0,255,224,.95)';
      roundedRect(-player.w/2, -player.h/2, player.w, player.h, 14);
      ctx.stroke();
      ctx.shadowBlur = 0;
      const cockpit = ctx.createRadialGradient(0,-4,2,0,-4,16);
      cockpit.addColorStop(0,'rgba(185,255,245,.95)');
      cockpit.addColorStop(1,'rgba(0,120,110,.45)');
      ctx.fillStyle = cockpit;
      ctx.beginPath();
      ctx.ellipse(0, -4, player.w*0.18, 12, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = 'rgba(158,255,0,.8)';
      ctx.beginPath();
      ctx.moveTo(-player.w/2+10, -8);
      ctx.lineTo(-player.w/2-20, 0);
      ctx.lineTo(-player.w/2+10, 8);
      ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(player.w/2-10, -8);
      ctx.lineTo(player.w/2+20, 0);
      ctx.lineTo(player.w/2-10, 8);
      ctx.closePath();
      ctx.fill();
      ctx.lineWidth = 5;
      ctx.strokeStyle = 'rgba(158,255,0,1)';
      ctx.shadowColor = 'rgba(158,255,0,.8)';
      ctx.shadowBlur = 18;
      ctx.beginPath();
      const armX = player.w*0.35;
      const topY = -player.h/2 - 64;
      const downY = -player.h/2 - 4;
      ctx.moveTo(-armX, topY);
      ctx.lineTo(-armX, downY);
      ctx.lineTo(armX, downY);
      ctx.lineTo(armX, topY);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.strokeStyle = 'rgba(158,255,0,.5)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, downY-4, armX-6, Math.PI, 0);
      ctx.stroke();
      ctx.fillStyle = 'rgba(158,255,0,1)';
      ctx.beginPath();
      ctx.moveTo(0, topY-18);
      ctx.lineTo(-10, topY-2);
      ctx.lineTo(10, topY-2);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function roundedRect(x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }

    function drawDrop(d){
      ctx.save();
      ctx.translate(d.x, d.y);
      const g = ctx.createRadialGradient(0,0,8,0,0,d.r);
      g.addColorStop(0,'rgba(158,255,0,.95)');
      g.addColorStop(1,'rgba(60,120,0,.55)');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(0,0,d.r,0,Math.PI*2);
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(158,255,0,.85)';
      ctx.stroke();
      ctx.fillStyle = '#041106';
      ctx.font = 'bold 20px Arial';
      const text = String(d.value);
      const tw = ctx.measureText(text).width;
      ctx.fillText(text, -tw/2, 7);
      ctx.shadowColor = 'rgba(158,255,0,.4)';
      ctx.shadowBlur = 12;
      ctx.beginPath();
      ctx.arc(0,0,d.r+3,0,Math.PI*2);
      ctx.strokeStyle = 'rgba(158,255,0,.4)';
      ctx.stroke();
      ctx.restore();
    }

    function update() {
      if(!running) return;
      player.x += player.vx;
      player.y += player.vy;
      const pad = 12;
      player.x = Math.max(pad + player.w/2, Math.min(CW() - pad - player.w/2, player.x));
      const minY = CH() - 160;
      const maxY = CH() - 40;
      player.y = Math.max(minY, Math.min(maxY, player.y));
      for(const d of drops){
        d.y += d.v;
        const halfW = player.w/2, halfH = player.h/2;
        const closestX = Math.max(player.x-halfW, Math.min(d.x, player.x+halfW));
        const closestY = Math.max(player.y-halfH, Math.min(d.y, player.y+halfH));
        const dx = d.x - closestX;
        const dy = d.y - closestY;
        if(dx*dx + dy*dy <= d.r*d.r){
          d.caught = true;
          if(d.value === currentQ.answer){
            score += 10;
            scoreEl.textContent = score;
            level = 1 + Math.floor(score / 40);
            levelEl.textContent = level;
            setBuddy('üéØ', 'Mantap! Chip yang kamu tangkap benar.');
          } else {
            lives = Math.max(0, lives - 1);
            const hearts = livesString();
            livesEl.textContent = hearts;
            setBuddy('‚ö†Ô∏è', 'Oops, itu bukan jawabannya. Hati-hati ya!');
          }
          syncHud();
        }
      }
      for(let i=drops.length-1;i>=0;i--){
        const d = drops[i];
        if(d.caught){
          drops.splice(i,1);
        } else if(d.y - d.r > CH()){
          if(d.value === currentQ.answer){
            lives = Math.max(0, lives - 1);
            const hearts = livesString();
            livesEl.textContent = hearts;
            setBuddy('üí•', 'Chip jawaban lolos! Nyawamu berkurang.');
          }
          drops.splice(i,1);
          syncHud();
        }
      }
      if(lives <= 0){
        handleGameOver();
        return;
      }
      if(running && drops.length === 0){
        newQuestion();
      }
    }

    function draw() {
      neonGridBackground();
      ctx.strokeStyle = 'rgba(0,255,224,.18)';
      ctx.beginPath();
      ctx.moveTo(0, CH() - 70);
      ctx.lineTo(CW(), CH() - 70);
      ctx.stroke();
      for(const d of drops) drawDrop(d);
      drawPlayer();
    }

    function frame(){
      if(running){
        update();
      }
      draw();
      animationId = requestAnimationFrame(frame);
    }

    function ensureAnimation(){
      if(animationId === null){
        animationId = requestAnimationFrame(frame);
      }
    }

    resetGame({ start: false });
    ensureAnimation();

    const keys = {ArrowLeft:false, ArrowRight:false, ArrowUp:false, ArrowDown:false};
    window.addEventListener('keydown', (e)=>{
      if(e.key === 'ArrowLeft'){ keys.ArrowLeft = true; }
      if(e.key === 'ArrowRight'){ keys.ArrowRight = true; }
      if(e.key === 'ArrowUp'){ keys.ArrowUp = true; }
      if(e.key === 'ArrowDown'){ keys.ArrowDown = true; }
      if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.key)) e.preventDefault();
      updateVelocity();
    });
    window.addEventListener('keyup', (e)=>{
      if(e.key === 'ArrowLeft'){ keys.ArrowLeft = false; }
      if(e.key === 'ArrowRight'){ keys.ArrowRight = false; }
      if(e.key === 'ArrowUp'){ keys.ArrowUp = false; }
      if(e.key === 'ArrowDown'){ keys.ArrowDown = false; }
      if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.key)) e.preventDefault();
      updateVelocity();
    });
    function updateVelocity(){
      player.vx = (keys.ArrowLeft?-player.speed:0) + (keys.ArrowRight?player.speed:0);
      player.vy = (keys.ArrowUp?-player.speed:0) + (keys.ArrowDown?player.speed:0);
    }
    leftBtn.addEventListener('touchstart', ()=>{ keys.ArrowLeft=true; updateVelocity(); }, {passive:false});
    leftBtn.addEventListener('touchend', ()=>{ keys.ArrowLeft=false; updateVelocity(); }, {passive:false});
    rightBtn.addEventListener('touchstart', ()=>{ keys.ArrowRight=true; updateVelocity(); }, {passive:false});
    rightBtn.addEventListener('touchend', ()=>{ keys.ArrowRight=false; updateVelocity(); }, {passive:false});
    dropBtn.addEventListener('touchstart', ()=>{ keys.ArrowDown=true; updateVelocity(); }, {passive:false});
    dropBtn.addEventListener('touchend', ()=>{ keys.ArrowDown=false; updateVelocity(); }, {passive:false});
    dropBtn.addEventListener('mousedown', ()=>{ keys.ArrowDown=true; updateVelocity(); });
    window.addEventListener('mouseup', ()=>{ keys.ArrowDown=false; updateVelocity(); });

    btnNew.addEventListener('click', ()=>{
      newQuestion();
      if(!running){
        setBuddy('üõ∏', 'Tekan Mulai untuk mulai bermain.');
      }
    });

    btnPause.addEventListener('click', ()=>{
      if(btnPause.disabled) return;
      running = !running;
      btnPause.textContent = running ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Resume';
      setBuddy(running ? 'üõ∏' : '‚è∏Ô∏è', running ? 'Lanjut! Tangkap jawaban yang benar.' : 'Permainan dijeda. Tekan Resume untuk lanjut.');
      syncHud(running ? 'Playing' : 'Paused');
    });

    btnReset.addEventListener('click', ()=>{
      resetGame({ start: false });
    });

    btnStartGame.addEventListener('click', ()=>{
      resetGame({ start: true });
    });

    function showStartButton(label = 'Mulai') {
      btnStartGame.textContent = label;
      btnStartGame.style.display = 'inline-flex';
      btnStartGame.disabled = false;
    }

    function hideStartButton() {
      btnStartGame.style.display = 'none';
    }

    function handleGameOver(){
      running = false;
      drops.length = 0;
      showStartButton('Mulai Lagi');
      btnPause.disabled = true;
      btnPause.textContent = '‚è∏Ô∏è Pause';
      qEl.textContent = 'Game Over';
      setBuddy('üí§', 'Game over! Tekan Mulai Lagi untuk mencoba kembali.');
      syncHud('Game Over');
    }

    function resetGame({ start = false } = {}){
      score = 0;
      level = 1;
      lives = maxLives;
      scoreEl.textContent = score;
      levelEl.textContent = level;
      livesEl.textContent = livesString();
      drops.length = 0;
      running = start;
      newQuestion();
      if(start){
        hideStartButton();
        btnPause.disabled = false;
        btnPause.textContent = '‚è∏Ô∏è Pause';
        setBuddy('üõ∏', 'Hovercraft siap! Tangkap chip jawaban yang benar.');
        syncHud('Playing');
      } else {
        running = false;
        showStartButton('Mulai');
        btnPause.disabled = true;
        btnPause.textContent = '‚è∏Ô∏è Pause';
        setBuddy('üõ∏', 'Tekan Mulai untuk mulai bermain.');
        syncHud('Ready');
      }
    }

    function resizeCanvasForHiDPI(){
      const dpr = window.devicePixelRatio || 1;
      const cssW = canvas.clientWidth;
      const cssH = canvas.clientHeight;
      const needW = Math.floor(cssW * dpr);
      const needH = Math.floor(cssH * dpr);
      if(canvas.width !== needW || canvas.height !== needH){
        canvas.width = needW; canvas.height = needH;
      }
      ctx.setTransform(1,0,0,1,0,0);
      ctx.scale(dpr, dpr);
    }
    const ro = new ResizeObserver(()=>resizeCanvasForHiDPI());
    ro.observe(canvas);
    resizeCanvasForHiDPI();
  </script>

  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="/elearn/manifest-lessons.js"></script>
  <script src="/elearn/userInfo.js"></script>
  <script src="/elearn/common/worksheet-submit.js"></script>
  <script>
    window.WORKSHEET_DEBUG = true;
    window.WORKSHEET_META = { course_id: "mathgame-basic" };
    const info = (typeof getUserInfo === "function") ? getUserInfo() : {};
    initWorksheetSubmit({
      muridUid: info.uid || "",
      cid: info.cid || "",
      namaAnak: info.nama || "",
      role: (info.role || "").toLowerCase()
    });
  </script>
  <script src="/elearn/common/calistung-navbar.js"></script>
</body>
</html>
