<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Math Game L13 – Neon Catch</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --neon:#00ffe0;
      --accent:#9eff00;
      --danger:#ff4d6d;
      --bg:#0b0f14;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: Inter, Arial, sans-serif;
      background: radial-gradient(1200px 600px at 50% 0%, #0f1a22 0%, var(--bg) 60%);
      color:#eaf7ff;
      text-align:center;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      align-items:center;
    }
    header{
      width:100%;
      max-width:900px;
      padding:14px 16px 0;
    }
    h1{
      margin:6px 0 2px;
      font-size: clamp(20px, 3vw, 28px);
      letter-spacing: .5px;
      color:#cfefff;
      text-shadow: 0 0 10px rgba(0,255,224,.35);
    }
    #question{
      font-size: clamp(18px, 2.5vw, 24px);
      margin:6px 0 10px;
      color:#b7fffb;
    }
    .hud{
      display:flex;justify-content:space-between;align-items:center;
      gap:8px;margin:6px auto 8px;max-width:900px;padding:0 16px;
      font-size:14px;color:#a9c8d6;
    }
    .hud .pill{
      border:1px solid rgba(0,255,224,.35);
      border-radius:999px;padding:6px 10px;display:inline-flex;
      align-items:center;gap:8px;box-shadow: inset 0 0 12px rgba(0,255,224,.12);
      background: rgba(0, 20, 25, .5);
    }
    .hearts{letter-spacing:4px;color:var(--danger)}
    .btn{
      appearance:none;border:1px solid rgba(0,255,224,.45);
      background: linear-gradient(180deg, rgba(0,255,224,.18), rgba(0,40,45,.3));
      box-shadow: 0 0 12px rgba(0,255,224,.15), inset 0 0 12px rgba(0,255,224,.12);
      color:#dff; padding:8px 14px;border-radius:10px;cursor:pointer;
      font-weight:600; letter-spacing:.2px; transition:.15s;
    }
    .btn:hover{transform:translateY(-1px); box-shadow:0 6px 18px rgba(0,255,224,.22)}
    .controls{
      display:flex;gap:10px;justify-content:center;align-items:center;margin:6px 0 10px;
      flex-wrap:wrap;
    }
    canvas{
      width:min(92vw, 900px);
      height: min(60vh, 540px);
      aspect-ratio: 16/10;
      border:2px solid rgba(0,255,224,.35);
      border-radius:14px;
      background:#081016;
      box-shadow: 0 0 30px rgba(0,255,224,.15), inset 0 0 40px rgba(0,255,224,.12);
      touch-action: none;
    }
    .touchpad{
      display:grid;grid-template-columns:repeat(3, min(120px, 28vw));gap:8px;
      justify-content:center;margin:8px 0 16px;
    }
    .pad{
      border:1px solid rgba(158,255,0,.4);
      background: linear-gradient(180deg, rgba(158,255,0,.18), rgba(40,55,0,.25));
      color:#e9ffd6;padding:10px;border-radius:12px;font-weight:700;cursor:pointer;
      user-select:none;
      touch-action: none;
    }
    footer{margin:10px 0 20px;color:#83a6b3;font-size:12px}
  </style>
</head>
<body>
  <header>
    <h1>Neon Catch — Level 13</h1>
    <div id="question">Siap?</div>
    <div class="hud">
      <div class="pill">Skor: <span id="score">0</span></div>
      <div class="pill">Level: <span id="level">1</span></div>
      <div class="pill">Nyawa: <span class="hearts" id="lives">❤❤❤</span></div>
    </div>
    <div class="controls">
      <button id="btnNew" class="btn">Acak Soal</button>
      <button id="btnPause" class="btn">Pause</button>
      <button id="btnReset" class="btn">Reset</button>
    </div>
  </header>

  <canvas id="game" width="900" height="560" aria-label="Neon Catch Math Game"></canvas>

  <div class="touchpad" aria-hidden="false">
    <div class="pad" id="left">◀︎</div>
    <div class="pad" id="drop">▼</div>
    <div class="pad" id="right">▶︎</div>
  </div>

  <footer>Gerakkan hovercraft dengan ◀︎ ▶︎ (atau sentuh). <strong>Rangka U neon di atas hovercraft = PENANGKAP</strong>. Arahkan tepat di bawah chip angka yang benar.</footer>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const qEl = document.getElementById('question');
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const livesEl = document.getElementById('lives');
    const btnNew = document.getElementById('btnNew');
    const btnPause = document.getElementById('btnPause');
    const btnReset = document.getElementById('btnReset');
    const leftBtn = document.getElementById('left');
    const rightBtn = document.getElementById('right');

    // Game state
    let running = true;
    let score = 0;
    let level = 1;
    let lives = 3;

    // Logical canvas size in CSS pixels (used for all game math)
    const CW = () => canvas.clientWidth;
    const CH = () => canvas.clientHeight;

    const player = {
      x: CW() / 2,
      y: CH() - 80,
      w: 160,
      h: 26,
      speed: 7,
      vx: 0,
      vy: 0
    };

    const drops = [];
    let currentQ = null;

    function neonGridBackground() {
      // hologram grid
      const spacing = 40;
      ctx.save();
      ctx.fillStyle = '#081016';
      ctx.fillRect(0,0,CW(),CH());
      ctx.strokeStyle = 'rgba(0,255,224,0.12)';
      ctx.lineWidth = 1;

      // perspective vertical lines
      for(let x=-200; x<=CW()+200; x+=spacing){
        ctx.beginPath();
        ctx.moveTo(x, CH()*0.35);
        ctx.lineTo((x+CW())/2, CH());
        ctx.stroke();
      }
      // horizontal lines
      for(let y=CH()*0.35; y<=CH(); y+=spacing){
        ctx.beginPath();
        ctx.moveTo(0,y);
        ctx.lineTo(CW(),y);
        ctx.stroke();
      }

      // top glow
      const g = ctx.createLinearGradient(0,0,0,120);
      g.addColorStop(0,'rgba(0,255,224,.22)');
      g.addColorStop(1,'rgba(0,255,224,0)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,CW(),120);
      ctx.restore();
    }

    function randomInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

    function newQuestion() {
      // Mix of + and − for kids, with occasional × at higher level
      const ops = level >= 3 ? ['+','-','×'] : ['+','-'];
      const op = ops[randomInt(0, ops.length-1)];
      let a = randomInt(1, 10);
      let b = randomInt(1, 10);
      if(op === '-' && b > a){ [a,b] = [b,a]; } // avoid negative
      if(op === '×'){ a = randomInt(2, 9); b = randomInt(2, 9); }

      let ans = (op === '+') ? a+b : (op === '-') ? a-b : a*b;

      // generate 2 wrong options near the answer
      const wrong1 = ans + randomInt(1,3);
      const wrong2 = Math.max(0, ans - randomInt(1,3));

      const opts = [ans, wrong1, wrong2].sort(()=>Math.random()-0.5);
      currentQ = { text: `${a} ${op} ${b} = ?`, answer: ans, options: opts };
      qEl.textContent = `Tangkap jawaban yang benar: ${currentQ.text}`;

      // spawn new chips
      drops.length = 0;
      const lanes = [CW()*0.2, CW()*0.5, CW()*0.8];
      for(let i=0;i<opts.length;i++){
        const drop = {
          x: lanes[i] + randomInt(-30,30),
          y: -randomInt(40,160),
          r: 26,
          v: 2.4 + level*0.3 + Math.random()*0.8,
          value: opts[i],
          caught:false
        };
        // keep entirely within canvas
        drop.x = Math.max(drop.r + 6, Math.min(CW() - drop.r - 6, drop.x));
        drops.push(drop);
      }
    }

    function drawPlayer() {
      // super-visible neon hovercraft + catcher frame
      ctx.save();
      ctx.translate(player.x, player.y);

      // UNDERGLOW
      ctx.save();
      ctx.globalAlpha = 0.55;
      const glow = ctx.createRadialGradient(0, 12, 6, 0, 12, 70);
      glow.addColorStop(0, 'rgba(0,255,224,.55)');
      glow.addColorStop(1, 'rgba(0,255,224,0)');
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.ellipse(0, 18, player.w*0.55, 14, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      // BODY
      const bodyGrad = ctx.createLinearGradient(0,-14,0,24);
      bodyGrad.addColorStop(0, 'rgba(0,255,224,.95)');
      bodyGrad.addColorStop(1, 'rgba(0,100,90,.65)');
      ctx.fillStyle = bodyGrad;
      roundedRect(-player.w/2, -player.h/2, player.w, player.h, 14);
      ctx.fill();

      // OUTLINE GLOW
      ctx.shadowColor = 'rgba(0,255,224,.9)';
      ctx.shadowBlur = 22;
      ctx.lineWidth = 3;
      ctx.strokeStyle = 'rgba(0,255,224,.95)';
      roundedRect(-player.w/2, -player.h/2, player.w, player.h, 14);
      ctx.stroke();

      // COCKPIT
      ctx.shadowBlur = 0;
      const cockpit = ctx.createRadialGradient(0,-4,2,0,-4,16);
      cockpit.addColorStop(0,'rgba(185,255,245,.95)');
      cockpit.addColorStop(1,'rgba(0,120,110,.45)');
      ctx.fillStyle = cockpit;
      ctx.beginPath();
      ctx.ellipse(0, -4, player.w*0.18, 12, 0, 0, Math.PI*2);
      ctx.fill();

      // FINS
      ctx.fillStyle = 'rgba(158,255,0,.8)';
      ctx.beginPath(); // left fin
      ctx.moveTo(-player.w/2+10, -8);
      ctx.lineTo(-player.w/2-20, 0);
      ctx.lineTo(-player.w/2+10, 8);
      ctx.closePath();
      ctx.fill();
      ctx.beginPath(); // right fin
      ctx.moveTo(player.w/2-10, -8);
      ctx.lineTo(player.w/2+20, 0);
      ctx.lineTo(player.w/2-10, 8);
      ctx.closePath();
      ctx.fill();

      // CATCHER FRAME (U-shape) — VERY VISIBLE
      ctx.lineWidth = 5;
      ctx.strokeStyle = 'rgba(158,255,0,1)';
      ctx.shadowColor = 'rgba(158,255,0,.8)';
      ctx.shadowBlur = 18;
      ctx.beginPath();
      const armX = player.w*0.35;
      const topY = -player.h/2 - 64;  // naik 30px
      const downY = -player.h/2 - 4;  // sedikit turun agar tebal
      // left arm
      ctx.moveTo(-armX, topY);
      ctx.lineTo(-armX, downY);
      // top bar
      ctx.lineTo(armX, downY);
      // right arm
      ctx.lineTo(armX, topY);
      ctx.stroke();

      // target arc guide
      ctx.shadowBlur = 0;
      ctx.strokeStyle = 'rgba(158,255,0,.5)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, downY-4, armX-6, Math.PI, 0);
      ctx.stroke();

      // GUIDE TRIANGLE pointing to catcher
      ctx.fillStyle = 'rgba(158,255,0,1)';
      ctx.beginPath();
      ctx.moveTo(0, topY-18);
      ctx.lineTo(-10, topY-2);
      ctx.lineTo(10, topY-2);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    function roundedRect(x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }

    function drawDrop(d){
      ctx.save();
      ctx.translate(d.x, d.y);
      // chip
      const g = ctx.createRadialGradient(0,0,8,0,0,d.r);
      g.addColorStop(0,'rgba(158,255,0,.95)');
      g.addColorStop(1,'rgba(60,120,0,.55)');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(0,0,d.r,0,Math.PI*2);
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(158,255,0,.85)';
      ctx.stroke();

      // number
      ctx.fillStyle = '#041106';
      ctx.font = 'bold 20px Arial';
      const text = String(d.value);
      const tw = ctx.measureText(text).width;
      ctx.fillText(text, -tw/2, 7);

      // halo
      ctx.shadowColor = 'rgba(158,255,0,.4)';
      ctx.shadowBlur = 12;
      ctx.beginPath();
      ctx.arc(0,0,d.r+3,0,Math.PI*2);
      ctx.strokeStyle = 'rgba(158,255,0,.4)';
      ctx.stroke();
      ctx.restore();
    }

    function update() {
      if(!running) return;

      // physics
      player.x += player.vx;
      player.y += player.vy;
      const pad = 12;
      player.x = Math.max(pad + player.w/2, Math.min(CW() - pad - player.w/2, player.x));
      const minY = CH() - 160; // allow moving a bit up so catcher visible
      const maxY = CH() - 40;  // keep above canvas bottom
      player.y = Math.max(minY, Math.min(maxY, player.y));

      for(const d of drops){
        d.y += d.v;
        // catch check (AABB with circle)
        const halfW = player.w/2, halfH = player.h/2;
        const closestX = Math.max(player.x-halfW, Math.min(d.x, player.x+halfW));
        const closestY = Math.max(player.y-halfH, Math.min(d.y, player.y+halfH));
        const dx = d.x - closestX;
        const dy = d.y - closestY;
        if(dx*dx + dy*dy <= d.r*d.r){
          d.caught = true;
          if(d.value === currentQ.answer){
            score += 10;
            scoreEl.textContent = score;
            level = 1 + Math.floor(score / 40);
            levelEl.textContent = level;
          } else {
            lives = Math.max(0, lives - 1);
            livesEl.textContent = '❤'.repeat(lives) + '♡'.repeat(3-lives);
          }
        }
      }

      // remove off-screen and caught
      for(let i=drops.length-1;i>=0;i--){
        const d = drops[i];
        if(d.caught){
          drops.splice(i,1);
        } else if(d.y - d.r > CH()){
          // missed chip: if the missed one was the correct answer, lose a life
          if(d.value === currentQ.answer){
            lives = Math.max(0, lives - 1);
            livesEl.textContent = '❤'.repeat(lives) + '♡'.repeat(3-lives);
          }
          drops.splice(i,1);
        }
      }

      // next wave or game over
      if(lives <= 0){
        running = false;
        qEl.textContent = `Game Over • Skor: ${score}. Tekan Reset untuk mulai lagi.`;
        return;
      }
      if(drops.length === 0){
        newQuestion();
      }
    }

    function draw() {
      neonGridBackground();
      // HUD faint line
      ctx.strokeStyle = 'rgba(0,255,224,.18)';
      ctx.beginPath();
      ctx.moveTo(0, CH() - 70);
      ctx.lineTo(CW(), CH() - 70);
      ctx.stroke();

      for(const d of drops) drawDrop(d);
      drawPlayer();
    }

    function loop(){
      update();
      draw();
      requestAnimationFrame(loop);
    }

    // Controls
    const keys = {ArrowLeft:false, ArrowRight:false, ArrowUp:false, ArrowDown:false};
    window.addEventListener('keydown', (e)=>{
      if(e.key === 'ArrowLeft'){ keys.ArrowLeft = true; }
      if(e.key === 'ArrowRight'){ keys.ArrowRight = true; }
      if(e.key === 'ArrowUp'){ keys.ArrowUp = true; }
      if(e.key === 'ArrowDown'){ keys.ArrowDown = true; }
      if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.key)) e.preventDefault();
      updateVelocity();
    });
    window.addEventListener('keyup', (e)=>{
      if(e.key === 'ArrowLeft'){ keys.ArrowLeft = false; }
      if(e.key === 'ArrowRight'){ keys.ArrowRight = false; }
      if(e.key === 'ArrowUp'){ keys.ArrowUp = false; }
      if(e.key === 'ArrowDown'){ keys.ArrowDown = false; }
      if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.key)) e.preventDefault();
      updateVelocity();
    });
    function updateVelocity(){
      player.vx = (keys.ArrowLeft?-player.speed:0) + (keys.ArrowRight?player.speed:0);
      player.vy = (keys.ArrowUp?-player.speed:0) + (keys.ArrowDown?player.speed:0);
    }
    leftBtn.addEventListener('touchstart', ()=>{ keys.ArrowLeft=true; updateVelocity(); }, {passive:false});
    leftBtn.addEventListener('touchend', ()=>{ keys.ArrowLeft=false; updateVelocity(); }, {passive:false});
    rightBtn.addEventListener('touchstart', ()=>{ keys.ArrowRight=true; updateVelocity(); }, {passive:false});
    rightBtn.addEventListener('touchend', ()=>{ keys.ArrowRight=false; updateVelocity(); }, {passive:false});
    const dropBtn = document.getElementById('drop');
    dropBtn.addEventListener('touchstart', ()=>{ keys.ArrowDown=true; updateVelocity(); }, {passive:false});
    dropBtn.addEventListener('touchend', ()=>{ keys.ArrowDown=false; updateVelocity(); }, {passive:false});
    dropBtn.addEventListener('mousedown', ()=>{ keys.ArrowDown=true; updateVelocity(); });
    window.addEventListener('mouseup', ()=>{ keys.ArrowDown=false; updateVelocity(); });

    // Buttons
    btnNew.addEventListener('click', ()=>{ newQuestion(); });
    btnPause.addEventListener('click', ()=>{
      running = !running;
      btnPause.textContent = running ? 'Pause' : 'Resume';
      if(running) loop();
    });
    btnReset.addEventListener('click', resetGame);

    function resetGame(){
      score = 0; level = 1; lives = 3;
      scoreEl.textContent = score;
      levelEl.textContent = level;
      livesEl.textContent = '❤❤❤';
      running = true;
      drops.length = 0;
      newQuestion();
    }

    // Start
    resetGame();
    loop();

    // Resize handling to keep crisp drawing on high‑DPI
    function resizeCanvasForHiDPI(){
      const dpr = window.devicePixelRatio || 1;
      const cssW = canvas.clientWidth;
      const cssH = canvas.clientHeight;
      const needW = Math.floor(cssW * dpr);
      const needH = Math.floor(cssH * dpr);
      if(canvas.width !== needW || canvas.height !== needH){
        canvas.width = needW; canvas.height = needH;
      }
      ctx.setTransform(1,0,0,1,0,0);
      ctx.scale(dpr, dpr);
    }
    const ro = new ResizeObserver(()=>resizeCanvasForHiDPI());
    ro.observe(canvas);
    resizeCanvasForHiDPI();
  </script>
</body>
</html>