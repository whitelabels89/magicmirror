<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>SHAPE L22 ‚Äì Unplugged Coding (Help the Fish!)</title>
<style>
  :root{
    --cell: 120px;       /* ukuran kotak */
    --gap: 8px;          /* jarak antar kotak */
    --cols: 4;
    --rows: 4;
    --board-pad: 10px;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,system-ui,Segoe UI,Helvetica,Arial,sans-serif;background:#0c2547;color:#f6ffff}
  header{padding:16px 16px 0}
  h1{font-size:22px;margin:0 0 6px 0;letter-spacing:.3px}
  .sub{opacity:.85;margin-bottom:14px}

  .wrap{display:grid;grid-template-columns:1fr 360px;gap:16px;padding:12px 16px 24px}
  @media (max-width: 980px){ .wrap{grid-template-columns:1fr} }

  /* BOARD */
  .board{position:relative;background:linear-gradient(180deg,#0d3b66,#144c7d 60%,#10639a);border-radius:14px;padding:var(--board-pad);box-shadow:0 10px 30px rgba(0,0,0,.35)}
  .grid{position:relative;display:grid;grid-template-columns:repeat(var(--cols), var(--cell));grid-template-rows:repeat(var(--rows), var(--cell));gap:var(--gap);}
  .cell{background:#f8fbff;border-radius:10px;box-shadow:inset 0 0 0 2px rgba(0,0,0,.06)}
  .overlay{position:absolute;inset:0;pointer-events:none}

  .tile{position:absolute;width:var(--cell);height:var(--cell);left:0;top:0;transform:none;display:flex;align-items:center;justify-content:center;border-radius:10px}

  /* sprites (emoji fallback biar cepat) */
  .sprite{font-size:56px;filter:drop-shadow(0 2px 2px rgba(0,0,0,.15))}
  .obstacle{opacity:.95}
  .mom .sprite{font-size:68px}
  .goal.baby .sprite{font-size:40px}

  /* PROGRAM BAR */
  .panel{background:#0b1e3a;border-radius:14px;padding:12px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
  .panel h3{margin:0 0 10px 0;font-size:16px}

  .dock{display:flex;flex-wrap:wrap;gap:8px;margin-bottom:8px}
  .card{
    width:64px;height:64px;border-radius:12px;background:#133a66;display:flex;align-items:center;justify-content:center;cursor:grab;user-select:none;box-shadow:inset 0 0 0 2px rgba(255,255,255,.06), 0 4px 12px rgba(0,0,0,.25);position:relative;
    touch-action:none;
    -webkit-user-select:none;
    -webkit-touch-callout:none;
  }
  .card:active{cursor:grabbing}
  .card .arrow{font-size:34px;pointer-events:none}

  .program{display:flex;flex-wrap:wrap;gap:8px;margin:10px 0}
  .dock, .program { touch-action:none; }
  .slot{width:64px;height:64px;border-radius:12px;background:#0a2b52;display:flex;align-items:center;justify-content:center;outline:2px dashed #315b87;outline-offset:-6px}

  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
  button{padding:8px 12px;border-radius:10px;border:0;background:#2b89ff;color:white;font-weight:700;cursor:pointer}
  button:disabled{opacity:.6;cursor:not-allowed}
  button.secondary{background:#154a86}
  .status{margin-top:8px;font-weight:600}
  .status.ok{color:#30d57d}
  .status.bad{color:#ff7272}

  /* drag util */
  .dragging{opacity:.85;box-shadow:0 8px 24px rgba(0,0,0,.45)}
  .board, .grid, .tile, .card, .slot, button{pointer-events:auto}
  button{position:relative;z-index:5}
</style>

  <link rel="stylesheet" href="/elearn/worlds/calistung/buttons.css" />
</head>
<body data-nav-badge="Calistung Shape" data-nav-home-url="/elearn/worlds/calistung/shape/index.html">
  <header>
    <h1>UNPLUGGED CODING</h1>
    <div class="sub">Gunakan kartu arah untuk membantu ikan menemukan bayinya.</div>
  </header>

  <div class="wrap">
    <!-- BOARD -->
    <section class="board">
      <div id="grid" class="grid" aria-label="papan 4x4"></div>
      <div class="overlay" id="overlay"></div>
    </section>

    <!-- SIDE PANEL -->
    <aside class="panel">
      <h3>Kartu Arah</h3>
      <div id="dock" class="dock"></div>

      <h3>Program</h3>
      <div id="program" class="program"></div>

      <div class="controls">
        <button id="run">Jalankan ‚ñ∂</button>
        <button id="reset" class="secondary">Reset ‚Ü∫</button>
        <button id="shuffleLevel" class="secondary">Acak Soal üîÄ</button>
        <button id="shuffle" class="secondary">Acak Kartu</button>
      </div>
      <div id="status" class="status"></div>
    </aside>
  </div>

<script>
// ====== Konfigurasi dasar ======
const CELL=120, GAP=8, ROWS=4, COLS=4; // selaras dengan CSS root
const START={c:1,r:1};      // posisi ikan (kolom, baris)
let BABIES = [];            // diisi ulang tiap reset/shuffle
let BABY_POS = {c:4, r:4};  // posisi kumpul bayi (acak saat acak soal)
function regenBabies(){
  const n = Math.random() < 0.5 ? 2 : 3; // 2 atau 3 ekor
  BABIES = Array.from({length:n}, ()=> ({c: BABY_POS.c, r: BABY_POS.r}));
}
const OBSTACLE_EMOJIS = ['‚≠êÔ∏è','üêö','üåø'];
let OBSTACLES = [];

const grid = document.getElementById('grid');
const overlay = document.getElementById('overlay');
const dock = document.getElementById('dock');
const program = document.getElementById('program');
const runBtn = document.getElementById('run');
const resetBtn = document.getElementById('reset');
const shuffleBtn = document.getElementById('shuffle');
if (shuffleBtn) { shuffleBtn.remove(); }
const statusEl = document.getElementById('status');
const shuffleLevelBtn = document.getElementById('shuffleLevel');

// ====== Random level helpers (ensure solvable) ======
function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
function randCell(){ return {c: randInt(1,COLS), r: randInt(1,ROWS)}; }
function sameCell(a,b){ return a.c===b.c && a.r===b.r; }
function cellTaken(pos){
  if(sameCell(pos, START)) return true;
  if(BABY_POS && sameCell(pos, BABY_POS)) return true;
  return false;
}
function regenObstacles(count=3){
  const used=new Set([`${START.c},${START.r}`, `${BABY_POS.c},${BABY_POS.r}`]);
  const list=[];
  while(list.length<count){
    const p=randCell(); const key=`${p.c},${p.r}`;
    if(used.has(key)) continue;
    used.add(key);
    list.push(p);
  }
  OBSTACLES = list.map((p,i)=>({c:p.c, r:p.r, emoji: OBSTACLE_EMOJIS[i%OBSTACLE_EMOJIS.length]}));
}
function regenLevelSolvable(maxTries=200){
  for(let t=0;t<maxTries;t++){
    // random baby pos not at START
    let p; do{ p=randCell(); }while(sameCell(p, START));
    BABY_POS = p;
    regenObstacles(3);
    regenBabies();
    const solved = solveToAny(START, BABIES);
    if(solved.path && solved.path.length){
      currentSolution = solved.path; currentTargetIndex = solved.targetIndex;
      return true;
    }
  }
  return false;
}

// ====== Path solver (BFS shortest path avoiding obstacles) ======
const DIRS = [
  {t:'U', dc:0, dr:-1},
  {t:'R', dc:1, dr:0},
  {t:'D', dc:0, dr:1},
  {t:'L', dc:-1, dr:0},
];
function key(c,r){ return c+','+r; }
function isBlocked(c,r){ return occupied(c,r) !== null; }
function solvePath(start=START, goal=GOAL){
  const q=[[start.c,start.r]]; const prev=new Map(); prev.set(key(start.c,start.r), null);
  while(q.length){
    const [c,r]=q.shift();
    if(c===goal.c && r===goal.r) break;
    for(const d of DIRS){
      const nc=c+d.dc, nr=r+d.dr;
      if(nc<1||nc>COLS||nr<1||nr>ROWS) continue;
      if(isBlocked(nc,nr)) continue;
      const k=key(nc,nr); if(prev.has(k)) continue;
      prev.set(k, {c,r, t:d.t}); q.push([nc,nr]);
    }
  }
  // reconstruct
  const path=[]; let cur=key(goal.c,goal.r);
  if(!prev.has(cur)) return path; // no path
  while(true){
    const p=prev.get(cur); if(!p) break; path.push(p.t); cur=key(p.c,p.r);
  }
  return path.reverse();
}
let currentSolution = [];

function solveToAny(start=START, babies=BABIES){
  let best=[], bestIdx=-1;
  babies.forEach((b,idx)=>{ const p=solvePath(start,b); if(p.length && (best.length===0 || p.length<best.length)){ best=p; bestIdx=idx; } });
  return {path: best, targetIndex: bestIdx};
}
let currentTargetIndex = -1;

// ====== Utility ======
function cellRect(c,r){
  const g = grid.getBoundingClientRect();
  const left = g.left + (c-1)*(CELL+GAP) + GAP/2 + window.scrollX;
  const top  = g.top  + (r-1)*(CELL+GAP) + GAP/2 + window.scrollY;
  return {left, top};
}
function snapTo(el,c,r){
  const p = cellRect(c,r);
  el.style.left = (p.left - grid.getBoundingClientRect().left - window.scrollX) + 'px';
  el.style.top  = (p.top  - grid.getBoundingClientRect().top  - window.scrollY) + 'px';
  el.dataset.c=c; el.dataset.r=r;
}

// hitung posisi piksel relatif ke grid untuk sel (c,r)
function tilePos(c,r){
  const p = cellRect(c,r);
  return {
    left: (p.left - grid.getBoundingClientRect().left - window.scrollX),
    top:  (p.top  - grid.getBoundingClientRect().top  - window.scrollY)
  };
}

// animasi perpindahan absolute left/top dengan CSS transition
function moveTo(el, leftPx, topPx, dur=260){
  return new Promise((resolve)=>{
    let resolved=false;
    const cleanup=()=>{ el.style.transition=''; };
    const onEnd=(e)=>{
      if(resolved) return;
      if(e.propertyName==='left' || e.propertyName==='top'){
        resolved=true; el.removeEventListener('transitionend', onEnd); cleanup(); resolve();
      }
    };
    const timer=setTimeout(()=>{ if(!resolved){ resolved=true; el.removeEventListener('transitionend', onEnd); cleanup(); resolve(); } }, dur+120);
    el.addEventListener('transitionend', onEnd);
    el.style.transition = `left ${dur}ms linear, top ${dur}ms linear`;
    requestAnimationFrame(()=>{ el.style.left = leftPx + 'px'; el.style.top = topPx + 'px'; });
  });
}

function setButtonsEnabled(enabled){
  [runBtn, resetBtn, shuffleLevelBtn, shuffleBtn].forEach(b=>{ if(b) b.disabled=!enabled; });
}

function mkCell(){ const d=document.createElement('div'); d.className='cell'; return d; }
function mkTile(cls,emoji){
  const d=document.createElement('div'); d.className='tile '+cls; d.innerHTML=`<div class="sprite">${emoji}</div>`; d.style.left='0px'; d.style.top='0px'; return d;
}

// Offsets kecil agar bayi yang satu sel tidak menumpuk di satu titik
function babyOffsets(n){
  // posisi simetris yang tetap aman di dalam sel 120px
  if(n<=1) return [{x:0,y:0}];
  if(n===2) return [{x:-14,y:-14},{x:14,y:14}];
  // n>=3
  return [{x:-16,y:-10},{x:16,y:-10},{x:0,y:16}];
}

// ====== Render board ======
function renderBoard(){
  grid.style.setProperty('--cols', COLS);
  grid.style.setProperty('--rows', ROWS);
  grid.innerHTML='';
  for(let r=1;r<=ROWS;r++) for(let c=1;c<=COLS;c++) grid.appendChild(mkCell());

  // Start (ibu ikan) ‚Äì bentuk sama dengan bayi, lebih besar
  const fish = mkTile('start mom','üêü'); fish.id='fish'; grid.appendChild(fish); snapTo(fish, START.c, START.r);
  const fishSprite = fish.querySelector('.sprite'); if(fishSprite){ fishSprite.style.transform='scaleX(-1)'; fishSprite.style.transition=''; }
  // Bayi ikan (2‚Äì3 ekor), bentuk sama lebih kecil
  const offs = babyOffsets(BABIES.length);
  BABIES.forEach((b,i)=>{
    const g = mkTile('goal baby','üêü'); g.id='goal'+i; grid.appendChild(g); snapTo(g, b.c, b.r);
    const o = offs[i] || {x:0,y:0};
    g.style.transform = `translate(${o.x}px, ${o.y}px)`;
  });
  // Obstacles
  OBSTACLES.forEach((o,i)=>{ const ob=mkTile('obstacle',''+o.emoji); ob.id='obs'+i; grid.appendChild(ob); snapTo(ob,o.c,o.r); });
}

// ====== Program cards ======
const ARROWS=[
  {type:'U', label:'‚Üë'},
  {type:'R', label:'‚Üí'},
  {type:'D', label:'‚Üì'},
  {type:'L', label:'‚Üê'},
];

function renderDock(){
  dock.innerHTML='';
  // ensure dock provides at least what solution needs
  const needCounts = {U:0,R:0,D:0,L:0};
  currentSolution.forEach(t=>needCounts[t]++);
  // add distractors (2 random extra)
  const extras = 2;
  for(let i=0;i<extras;i++){
    const pick = ['U','R','D','L'][Math.floor(Math.random()*4)];
    needCounts[pick]++;
  }
  const list=[];
  Object.entries(needCounts).forEach(([t,n])=>{ for(let i=0;i<n;i++) list.push(t); });
  // shuffle visualize
  list.sort(()=>Math.random()-.5);
  list.forEach(t=>{
    const label = ({U:'‚Üë',R:'‚Üí',D:'‚Üì',L:'‚Üê'})[t];
    const card=document.createElement('div');
    card.className='card shape';
    card.dataset.type=t;
    card.dataset.from='dock';
    card.innerHTML=`<div class="arrow">${label}</div>`;
    dock.appendChild(card);
  });
}

function renderProgram(){
  program.innerHTML='';
  for(let i=0;i<Math.max(currentSolution.length, 6); i++){
    const s=document.createElement('div'); s.className='slot'; s.dataset.index=i; program.appendChild(s);
  }
}

// ====== Drag & drop for cards into program slots ======
(function enableDrag(){
  let active=null, pid=null, sx=0, sy=0, ox=0, oy=0, originParent=null;

  function start(e){
    const t=e.target.closest('.card');
    if(!t) return;
    active=t; pid=e.pointerId; active.setPointerCapture(pid);
    originParent = active.parentElement;
    active.classList.add('dragging');
    const rect=active.getBoundingClientRect();
    ox=rect.left + window.scrollX; oy=rect.top + window.scrollY;
    sx=e.clientX; sy=e.clientY;
    active.style.position='absolute';
    active.style.left=ox+'px'; active.style.top=oy+'px';
    document.body.appendChild(active); // move to top layer while dragging
    document.body.style.userSelect='none';
    document.body.style.overflow='hidden';
    e.preventDefault(); e.stopPropagation();
  }

  function move(e){ if(!active) return; active.style.left=(ox + e.clientX - sx)+'px'; active.style.top=(oy + e.clientY - sy)+'px'; e.preventDefault(); }

  function finish(){
    if(!active) return;
    try{active.releasePointerCapture(pid);}catch(_){ }
    const a=active; active=null; document.body.style.userSelect='';
    document.body.style.overflow='';
    // drop to nearest slot (within program area)
    const slots=[...program.querySelectorAll('.slot')];
    let best=null, bestDist=1e9;
    const ax=a.getBoundingClientRect();
    slots.forEach(s=>{
      const r=s.getBoundingClientRect();
      const cx=r.left+r.width/2, cy=r.top+r.height/2;
      const dx=Math.abs((ax.left+ax.width/2)-cx)+Math.abs((ax.top+ax.height/2)-cy);
      if(dx<bestDist){bestDist=dx; best=s;}
    });
    if(best && bestDist<300 && !best.firstChild){
      // snap into slot
      a.style.position=''; a.style.left=''; a.style.top='';
      best.appendChild(a);
    }else{
      // return to dock
      a.style.position=''; a.style.left=''; a.style.top='';
      dock.appendChild(a);
    }
  }

  document.addEventListener('pointerdown', start);
  document.addEventListener('pointermove', move, {passive:false});
  document.addEventListener('pointerup', finish, {passive:true});
  document.addEventListener('pointercancel', finish, {passive:true});
})();

// ====== Run simulation ======
function resetFish(){
  const fish=document.getElementById('fish');
  snapTo(fish, START.c, START.r);
  const sp = fish && fish.querySelector ? fish.querySelector('.sprite') : null;
  if(sp){ sp.style.transition=''; sp.style.transform='scaleX(-1)'; }
  statusEl.textContent=''; statusEl.className='status';
}

function occupied(c,r){
  if(c<1||c>COLS||r<1||r>ROWS) return 'wall';
  for(const o of OBSTACLES){ if(o.c===c && o.r===r) return 'obstacle'; }
  return null;
}

async function runProgram(){
  setButtonsEnabled(false);
  resetFish();
  const fish=document.getElementById('fish');
  const sprite = fish.querySelector('.sprite');
  let c=START.c, r=START.r;
  const cmds=[...program.querySelectorAll('.card')].map(el=>el.dataset.type);
  if(cmds.length===0){ statusEl.textContent='Susun kartu arah dulu ya üôÇ'; statusEl.className='status bad'; setButtonsEnabled(true); return; }

  // Orientasi persistent pakai flip horizontal saja (scaleX). Vertikal tidak mengubah orientasi.
  let face = -1; // -1 = kanan (mirror), 1 = kiri (default emoji)

  for(let i=0;i<cmds.length;i++){
    const t=cmds[i];
    // update orientasi (flip horizontal saja)
    if(t==='R') face = -1; else if(t==='L') face = 1; // U/D: pertahankan
    if(sprite){
      sprite.style.transition='transform 140ms linear';
      sprite.style.transform=`scaleX(${face})`;
    }

    // tentukan target sel berikutnya
    let nc=c, nr=r;
    if(t==='U') nr--; else if(t==='D') nr++; else if(t==='L') nc--; else if(t==='R') nc++;

    const hit=occupied(nc,nr);
    if(hit){
      statusEl.textContent = hit==='obstacle'? 'Aduh, nabrak rintangan!' : 'Keluar papan!';
      statusEl.className='status bad';
      // animasi shake kecil pada tile
      fish.animate([
        {transform:'translate(0,0)'},
        {transform:'translate(-4px,0)'},
        {transform:'translate(4px,0)'},
        {transform:'translate(0,0)'}
      ],{duration:280});
      setButtonsEnabled(true);
      return;
    }

    // animasi melangkah ke sel berikutnya
    const pos = tilePos(nc,nr);
    await moveTo(fish, pos.left, pos.top, 260);
    c=nc; r=nr;
  }

  // posisi akhir
  const meet = BABIES.some(b=>b.c===c && b.r===r);
  if(meet){ statusEl.textContent='Mantap! Ibu ikan bertemu bayinya üêüüíô'; statusEl.className='status ok'; }
  else { statusEl.textContent='Belum sampai ke bayi. Coba lagi!'; statusEl.className='status bad'; }
  setButtonsEnabled(true);
}

// ====== Wiring ======
// Inisialisasi level yang solvable
if(!regenLevelSolvable()){
  // fallback: pakai BABY_POS default & tanpa obstacle
  OBSTACLES=[]; regenBabies(); ({path: currentSolution, targetIndex: currentTargetIndex} = solveToAny(START, BABIES));
}
renderBoard();
renderDock();
renderProgram();

runBtn.addEventListener('click', runProgram);
resetBtn.addEventListener('click', ()=>{
  // kembalikan semua kartu dari program ke dock (tanpa mengacak ulang)
  [...program.querySelectorAll('.card')].forEach(c=>{ c.style.position=''; c.style.left=''; c.style.top=''; dock.appendChild(c); });
  // render ulang slot program kosong sesuai panjang solusi saat ini (minimal 6 slot)
  renderProgram();
  // reset posisi ikan & status
  resetFish();
  statusEl.textContent='';
  statusEl.className='status';
});
shuffleLevelBtn.addEventListener('click', ()=>{
  if(!regenLevelSolvable()){
    OBSTACLES=[]; regenBabies(); ({path: currentSolution, targetIndex: currentTargetIndex} = solveToAny(START, BABIES));
  }
  renderBoard(); renderDock(); renderProgram(); statusEl.textContent='Soal diacak.'; statusEl.className='status';
});
// (dihapus) tombol acak kartu ditiadakan

</script>
<style>
  .finish-bar { position: fixed; right: 16px; bottom: 16px; z-index: 1000; }
  #btnSelesai { background: #22c55e; color: #fff; border: none; cursor: pointer; padding: 12px 16px; border-radius: 12px; font-weight: 700; font-size: 16px; box-shadow: 0 6px 18px rgba(16, 185, 129, 0.4); }
  #btnSelesai:hover { filter: brightness(1.05); }
  #btnSelesai:active { transform: translateY(1px); }
  @media (max-width: 480px) { #btnSelesai { padding: 10px 14px; font-size: 15px; } }
</style>

<div class="finish-bar"><button id="btnSelesai" type="button">Selesai</button></div>

<!-- Tambah html2canvas hanya jika belum ada di halaman -->
<script>if(!window.html2canvas){document.write('<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"><\/script>')}</script>

<!-- Tambah manifest & user info hanya jika belum ada -->
<script>window.__hasManifestLessons||(document.write('<script src="/elearn/manifest-lessons.js"><\/script>'),window.__hasManifestLessons=true);</script>
<script>window.__hasUserInfo||(document.write('<script src="/elearn/userInfo.js"><\/script>'),window.__hasUserInfo=true);</script>

<!-- Tambah worksheet-submit hanya jika belum ada -->
<script>window.__hasWorksheetSubmit||(document.write('<script src="/elearn/common/worksheet-submit.js"><\/script>'),window.__hasWorksheetSubmit=true);</script>

<script>
  window.WORKSHEET_DEBUG = true;

  // Cari elemen target screenshot (prioritas canvas bila ada)
  ;(function ensureScreenshotRoot(){
    if (!document.getElementById('gameRoot') &&
        !document.getElementById('shapeBoard') &&
        !document.getElementById('canvasRoot')) {
      // Bungkus seluruh isi body KECUALI finish-bar ke dalam #gameRoot
      const wrap = document.createElement('div'); wrap.id = 'gameRoot';
      const bar = document.querySelector('.finish-bar');
      const bodyKids = Array.from(document.body.children).filter(n => n !== bar);
      bodyKids.forEach(n => wrap.appendChild(n));
      document.body.insertBefore(wrap, bar || null);
    }
  })();

  // Init submitter
  ;(function initSubmit(){
    const info = (typeof getUserInfo === "function") ? getUserInfo() : {};
    if (typeof initWorksheetSubmit === "function") {
      initWorksheetSubmit({
        muridUid: info.uid || "",
        cid: info.cid || "",
        namaAnak: info.nama || "",
        role: (info.role || "").toLowerCase(),

        // Opsi opsional khusus Shape:
        // prioritas canvas screenshot jika ada:
        screenshotSelectorPriority: ['#shapeCanvas', '#gameCanvas', '#canvasRoot', '#shapeBoard', '#gameRoot']
      });
    } else {
      console.warn("initWorksheetSubmit tidak ditemukan. Pastikan /elearn/common/worksheet-submit.js termuat.");
    }
  })();
</script>


<script src="/elearn/common/calistung-navbar.js"></script>
</body>
</html>
