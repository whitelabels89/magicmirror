<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>KinderCoder â€“ Level 1 (2.5D)</title>
  <style>
    :root{
      --bg:#0b0f17; --panel:#0f1520; --muted:#9aa4b2; --accent:#22c55e; --warn:#ef4444;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:#e6edf3;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial,sans-serif}
    .wrap{display:grid;grid-template-columns:360px 1fr;gap:10px;height:100%}
    .left{background:var(--panel);border:1px solid #1f2433;border-radius:12px;margin:10px;padding:12px;display:flex;flex-direction:column}
    .right{position:relative;background:var(--panel);border:1px solid #1f2433;border-radius:12px;margin:10px;overflow:hidden}

    /* Top slides 1..12 */
    .top-slides{position:absolute;top:10px;left:50%;transform:translateX(-50%);display:flex;gap:8px;z-index:30;background:rgba(11,18,32,.75);backdrop-filter:blur(6px);border:1px solid #1f2937;padding:8px 12px;border-radius:999px}
    .slide-dot{width:28px;height:28px;border-radius:50%;display:grid;place-items:center;font-weight:800;font-size:12px;color:#0b1220;background:#22c55e;cursor:pointer;user-select:none}
    .slide-dot.inactive{background:#334155;color:#e5e7eb}

    /* Board */
    .board{position:absolute;inset:0;display:grid;place-items:center}
    .sea{position:absolute;inset:0; z-index:0;
      background:#0a1a2b url('/elearn/models/ts-up/Terrain/Water/Water.png') 0 0 / 512px 512px repeat;
      animation:seaDrift 18s linear infinite;
    }
    .sea-foam{position:absolute;inset:0;pointer-events:none;
      background:url('/elearn/models/ts-up/Terrain/Water/Foam/Foam.png') 0 0 / 512px 512px repeat;
      opacity:.35;mix-blend-mode:screen;animation:seaDrift2 26s linear infinite; display:none;
    }

    @keyframes seaDrift{from{background-position:0 0} to{background-position:512px 256px}}
    @keyframes seaDrift2{from{background-position:0 0} to{background-position:-384px 192px}}

    /* Island base (simple 2.5D grid illusion) */
    .island{position:relative; z-index:2; width:min(86vmin,960px);height:calc(min(86vmin,960px)*0.7);
      filter:drop-shadow(0 30px 40px rgba(0,0,0,.35));}
    .tiles{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);display:grid;grid-template-columns:repeat(6,64px);grid-auto-rows:64px;gap:2px}
    .tile{width:64px;height:64px;border-radius:8px;background:linear-gradient(180deg,#e9c59a,#cf6f3b);box-shadow:inset 0 6px 0 rgba(255,255,255,.25)}
    .tile.goal{background:linear-gradient(180deg,#ffd479,#e19a60)}

    /* Canvas board (draw tiles from spritesheet) */
    #boardCanvas{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);image-rendering:pixelated;image-rendering:crisp-edges}

    /* Sea animation canvas */
    #seaAnim{position:absolute;inset:0;z-index:1;image-rendering:pixelated;image-rendering:crisp-edges}

    /* Sprites */
    .sprite{position:absolute;width:80px;height:80px;transform:translate(-50%,-50%);
      transition:left .22s linear, top .22s linear, rotate .18s ease;
    }
    .hero{background:url('/elearn/models/ts-fp/Units/Black Units/Warrior/Warrior_Idle.png') center/contain no-repeat}
    .hero.run{background:url('/elearn/models/ts-fp/Units/Black Units/Warrior/Warrior_Run.png') center/contain no-repeat}
    .gem{background:url('/elearn/models/ts-up/Resources/Resources/G_Idle.png') center/contain no-repeat;filter:drop-shadow(0 6px 10px rgba(255,215,0,.6))}
    .tree{background-position:center;background-repeat:no-repeat;background-size:contain}

    /* Side play button */
    .side-play{position:absolute;right:18px;top:50%;transform:translateY(-50%);z-index:40;display:flex;flex-direction:column;align-items:center;gap:8px}
    .side-play .big-play{width:72px;height:72px;border-radius:50%;border:0;background:#22c55e;color:#0b1220;font-size:28px;font-weight:900;display:grid;place-items:center;cursor:pointer;box-shadow:0 10px 24px rgba(0,0,0,.35)}
    .side-play .tip{font-size:12px;color:#9aa4b2;background:#0b1220;border:1px solid #1f2937;padding:4px 8px;border-radius:8px}

    .hud{margin-top:6px;font-size:12px;color:var(--muted)}
    .controls{margin-top:8px;display:flex;gap:8px;flex-wrap:wrap}
    .btn{background:#1f2937;color:#e6edf3;border:1px solid #2a3446;border-radius:8px;padding:8px 10px;cursor:pointer}
    .btn.run{background:#22c55e;color:#0b1220;font-weight:800}
  </style>
</head>
<body>
  <div class="wrap">
    <aside class="left">
      <h3 style="margin:4px 0 8px">Level 1 â€“ Ambil Permata âœ¨</h3>
      <div class="hud">Tujuan: gerakkan pahlawan ke kotak <b>permata</b>. Gunakan move & belok.</div>
      <div class="controls">
        <button class="btn" id="btnStep">Step</button>
        <button class="btn" id="btnReset">Reset</button>
        <button class="btn run" id="btnRun">Jalankan</button>
      </div>
      <div class="hud">(Nanti panel ini bisa diganti dengan Blockly / Script sesuai mode bahasa)</div>
    </aside>

    <section class="right" aria-label="board">
      <nav class="top-slides" aria-label="slides">
        <div class="slide-dot">1</div>
        <div class="slide-dot inactive">2</div>
        <div class="slide-dot inactive">3</div>
        <div class="slide-dot inactive">4</div>
        <div class="slide-dot inactive">5</div>
        <div class="slide-dot inactive">6</div>
        <div class="slide-dot inactive">7</div>
        <div class="slide-dot inactive">8</div>
        <div class="slide-dot inactive">9</div>
        <div class="slide-dot inactive">10</div>
        <div class="slide-dot inactive">11</div>
        <div class="slide-dot inactive">12</div>
      </nav>

      <div class="board">
        <div class="sea"></div>
        <canvas id="seaAnim"></canvas>
        <div class="sea-foam"></div>
        <div class="island">
          <canvas id="boardCanvas" width="0" height="0"></canvas>
          <!-- Sprites are placed absolute relative to .island -->
          <div class="sprite hero" id="hero"></div>
          <div class="sprite gem" id="goal"></div>
        </div>
      </div>

      <aside class="side-play">
        <button class="big-play" id="btnPlaySide" title="Jalankan">â–¶</button>
        <div class="tip">Jalankan</div>
      </aside>
    </section>
  </div>

  <script>
    // ===== Sea animated frames (12-frame spritesheet)
    const seaCanvas = document.getElementById('seaAnim');
    const seaCtx = seaCanvas.getContext('2d');

    function sizeSeaCanvas(){
      const board = document.querySelector('.board').getBoundingClientRect();
      const dpr2 = window.devicePixelRatio || 1;
      seaCanvas.style.width = board.width + 'px';
      seaCanvas.style.height = board.height + 'px';
      seaCanvas.width = Math.floor(board.width * dpr2);
      seaCanvas.height = Math.floor(board.height * dpr2);
      seaCtx.setTransform(dpr2,0,0,dpr2,0,0);
    }

    const waterCandidates = [
      '/elearn/models/ts-fp/Terrain/Water_FlatGround_(12frames).png',
      '/elearn/models/ts-fp/Terrain/Water/Water_FlatGround_(12frames).png',
      '/elearn/models/ts-up/Terrain/Water/Water_FlatGround_(12frames).png'
    ];

    function loadFirst(paths, cb){
      if(!paths.length) return;
      const p = paths[0];
      const img = new Image();
      img.onload = ()=> cb(img);
      img.onerror = ()=> loadFirst(paths.slice(1), cb);
      img.src = p;
    }

    let seaImg=null, frame=0, last=0;
    function drawSea(ts){
      if(!seaImg){ requestAnimationFrame(drawSea); return; }
      const now = performance.now();
      if(now - last > 90){ frame = (frame+1)%12; last = now; }
      seaCtx.clearRect(0,0,seaCanvas.width, seaCanvas.height);
      const horiz = seaImg.width / 12; // assume horizontal strip
      const fh = seaImg.height; const fw = horiz; // frame size
      const sx = frame*fw, sy = 0;
      // tile across canvas
      const styleW = parseFloat(seaCanvas.style.width);
      const styleH = parseFloat(seaCanvas.style.height);
      for(let y=0;y<styleH;y+=fh){
        for(let x=0;x<styleW;x+=fw){
          seaCtx.drawImage(seaImg, sx, sy, fw, fh, x, y, fw, fh);
        }
      }
      requestAnimationFrame(drawSea);
    }

    sizeSeaCanvas();
    (function(){
      const primary = new Image();
      primary.onload = ()=>{ seaImg = primary; drawSea(); };
      primary.onerror = ()=> loadFirst(waterCandidates, img=>{ seaImg = img; drawSea(); });
      primary.src = '/elearn/models/ts-fp/Terrain/Water_FlatGround_(12frames).png';
    })();

    // ===== Level 1 data (6x4 grid) =====
    const ROWS = 4, COLS = 6;
    const start = {r: 3, c: 0}; // kiri bawah
    const goal  = {r: 1, c: 4}; // agak ke kanan atas

    // 0=tanah, 1=kosong/air (tidak bisa diinjak)
    // Bentuk pulau sederhana (boolean mask):
    const mask = [
      [0,0,0,0,1,1],
      [0,0,0,0,0,1],
      [0,0,0,0,0,0],
      [0,0,0,0,0,0],
    ];

    // ===== Tile atlas mapping (use col/row indices; tweak if your sheet differs)
    const TILE_SIZE = 64;
    const atlas = (col,row)=>({sx:col*TILE_SIZE, sy:row*TILE_SIZE});
    // Default guess for Tiny Swords Tilemap_Flat.png (sand + dark shoreline)
    // center  : mid sand
    // edges   : T/B/L/R
    // corners : TL/TR/BL/BR
    const ATLAS = {
      center: atlas(3,2),
      edgeT:  atlas(3,1),
      edgeB:  atlas(3,3),
      edgeL:  atlas(2,2),
      edgeR:  atlas(4,2),
      cTL:    atlas(2,1),
      cTR:    atlas(4,1),
      cBL:    atlas(2,3),
      cBR:    atlas(4,3)
    };

    function pickTile(r,c){
      // land if mask[r][c]===0, hole/water if 1
      const land = (rr,cc)=> rr>=0 && cc>=0 && rr<ROWS && cc<COLS && mask[rr][cc]===0;
      const n = land(r-1,c), s = land(r+1,c), w = land(r,c-1), e = land(r,c+1);
      // corners (missing both directions)
      if(!n && !w) return ATLAS.cTL;
      if(!n && !e) return ATLAS.cTR;
      if(!s && !w) return ATLAS.cBL;
      if(!s && !e) return ATLAS.cBR;
      // edges
      if(!n) return ATLAS.edgeT;
      if(!s) return ATLAS.edgeB;
      if(!w) return ATLAS.edgeL;
      if(!e) return ATLAS.edgeR;
      return ATLAS.center;
    }

    // ===== Build tiles on canvas from spritesheet
    const TILE = 64;
    const canvas = document.getElementById('boardCanvas');
    const ctx = canvas.getContext('2d');
    // Style size (CSS pixels)
    const styleW = COLS * TILE;
    const styleH = ROWS * TILE;
    canvas.style.width = styleW + 'px';
    canvas.style.height = styleH + 'px';
    // Real pixels (for HiDPI)
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.floor(styleW * dpr);
    canvas.height = Math.floor(styleH * dpr);
    ctx.scale(dpr, dpr);
    ctx.imageSmoothingEnabled = false;

    const islandEl = document.querySelector('.island');

    // Load tileset image once (prioritize ts-fp/Terrain)
    const tileCandidates = [
      '/elearn/models/ts-fp/Terrain/Tilemap_Flat.png',
      '/elearn/models/ts-fp/Terrain/Tilemap_color1.png',
      '/elearn/models/ts-fp/Terrain/Tilemap_color2.png',
      '/elearn/models/ts-up/Terrain/Ground/Tilemap_Flat.png'
    ];
    let tileImg = null;
    loadFirst(tileCandidates, img=>{ tileImg = img; drawBoard(); sprinkleDeco(); });

    function drawBoard(){
      ctx.clearRect(0,0,styleW,styleH);
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          if(mask[r][c]===1) continue; // hole/water
          const t = pickTile(r,c);
          ctx.drawImage(tileImg, t.sx, t.sy, 64, 64, c*TILE+0.5, r*TILE+0.5, TILE, TILE);
        }
      }
    }

    // Crop a single tree from spritesheet to avoid repeated rows (auto-crop, robust)
    let TREE_URL = null;
    (function generateTreeTexture(){
      const candidates = [
        '/elearn/models/ts-fp/Resources/Trees/Tree.png',
        '/elearn/models/ts-up/Resources/Trees/Tree.png',
        '/elearn/models/ts-fp/Decorations/Trees/Tree.png'
      ];
      loadFirst(candidates, (img)=>{
        const off = document.createElement('canvas');
        off.width = img.width; off.height = img.height;
        const octx = off.getContext('2d'); octx.imageSmoothingEnabled = false;
        octx.drawImage(img, 0, 0);
        const data = octx.getImageData(0,0,off.width,off.height).data;
        // scan left half for first big opaque cluster bounding box
        let minX=off.width, minY=off.height, maxX=0, maxY=0;
        for(let y=0;y<off.height;y++){
          for(let x=0;x<Math.floor(off.width*0.6);x++){
            const a = data[(y*off.width + x)*4 + 3];
            if(a>10){
              if(x<minX) minX=x; if(x>maxX) maxX=x;
              if(y<minY) minY=y; if(y>maxY) maxY=y;
            }
          }
        }
        // pad a bit and sanity check
        if(maxX>minX && maxY>minY){
          const pad=10; minX=Math.max(0,minX-pad); minY=Math.max(0,minY-pad);
          maxX=Math.min(off.width, maxX+pad); maxY=Math.min(off.height, maxY+pad+24);
          const w=maxX-minX, h=maxY-minY;
          const cut=document.createElement('canvas'); cut.width=w; cut.height=h;
          const cctx=cut.getContext('2d'); cctx.imageSmoothingEnabled=false;
          cctx.drawImage(off, minX, minY, w, h, 0,0,w,h);
          TREE_URL = cut.toDataURL('image/png');
        }
      });
    })();

    // Crop a single rock from spritesheet (fallback ke update pack jika free pack tidak ada)
    let ROCK_URL = null;
    (function generateRockTexture(){
      const candidates = [
        '/elearn/models/ts-fp/Resources/Rocks/Rock.png',
        '/elearn/models/ts-up/Resources/Rocks/Rock.png',
        '/elearn/models/ts-up/Deco/07.png',
        '/elearn/models/ts-up/Deco/08.png'
      ];
      loadFirst(candidates, (img)=>{
        // Ambil kotak kiri-atas 256x256 sebagai default
        const w = 256, h = 256, sx = 0, sy = 0;
        const off = document.createElement('canvas'); off.width = w; off.height = h;
        const octx = off.getContext('2d'); octx.imageSmoothingEnabled = false;
        octx.drawImage(img, sx, sy, w, h, 0, 0, w, h);
        ROCK_URL = off.toDataURL('image/png');
      });
    })();

    // ===== Auto decorations (trees/rocks) on land near shore
    function sprinkleDeco(){
      const island = document.querySelector('.island');
      // Clear previous generated deco
      island.querySelectorAll('.deco').forEach(n=>n.remove());
      const candidates = [];
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          if(mask[r][c]===0){
            // near shore if at least one neighbor is water or out of bounds
            const nearWater = (r-1<0||mask[r-1][c]===1) || (r+1>=ROWS||mask[r+1][c]===1) || (c-1<0||mask[r][c-1]===1) || (c+1>=COLS||mask[r][c+1]===1);
            const notHero = !(r===start.r && c===start.c);
            const notGoal = !(r===goal.r && c===goal.c);
            if(nearWater && notHero && notGoal && r>0 && r<ROWS-1 && c>0 && c<COLS-1 && Math.random()<0.5) candidates.push({r,c});
          }
        }
      }
      // pick up to 6 random spots
      const picks = Math.min(6,candidates.length);
      for(let i=0;i<picks;i++){
        const idx = Math.floor(Math.random()*candidates.length);
        const {r,c} = candidates.splice(idx,1)[0];
        const el = document.createElement('div');
        el.className = 'sprite deco';
        const useRock = ROCK_URL && Math.random() < 0.4; // 40% batu, 60% pohon
        if(useRock){
          el.style.backgroundImage = `url(${ROCK_URL})`;
        }else if(TREE_URL){
          el.style.backgroundImage = `url(${TREE_URL})`;
        }
        // size variation by type
        let size;
        if(el.style.backgroundImage && el.style.backgroundImage.includes('data:image')){
          // pakai rentang beda untuk rock vs tree berdasarkan flag useRock
          size = useRock ? (72 + Math.floor(Math.random()*25)) : (84 + Math.floor(Math.random()*25));
        }else{
          size = 84 + Math.floor(Math.random()*25);
        }
        el.style.width = size + 'px';
        el.style.height = size + 'px';
        // small random rotation to break uniformity
        const rot = (Math.floor(Math.random()*7) - 3); // -3..+3 deg
        el.style.rotate = rot + 'deg';
        // place centered on cell first
        placeAt(el, r, c);
        // then add small random offset to break straight rows
        const dx = Math.floor(Math.random()*21) - 10; // -10..+10 px
        const dy = Math.floor(Math.random()*13) - 6;  //  -6..+6 px
        el.style.left = (parseFloat(el.style.left) + dx) + 'px';
        el.style.top  = (parseFloat(el.style.top)  + dy) + 'px';
        island.appendChild(el);
      }
    }

    // Helper to convert grid rc to pixel center within canvas, then to island coords
    function centerPx(r,c){
      return { x: c*TILE + TILE/2, y: r*TILE + TILE/2 };
    }
    function placeAt(el, r, c){
      const host = islandEl.getBoundingClientRect();
      const cvs  = canvas.getBoundingClientRect();
      const p = centerPx(r,c);
      const x = cvs.left - host.left + p.x;
      const y = cvs.top  - host.top  + p.y;
      el.style.left = x + 'px';
      el.style.top  = y + 'px';
    }

    // ===== Place sprites based on tile positions
    const heroEl = document.getElementById('hero');
    const goalEl = document.getElementById('goal');
    placeAt(heroEl, start.r, start.c);
    placeAt(goalEl, goal.r, goal.c);

    // ===== Simple runner (placeholder): moveâ†’c+1, left/right rotate dir
    let dir = 0; // 0:+x,1:+y,2:-x,3:-y
    let pos = { ...start };

    async function sleep(ms){return new Promise(r=>setTimeout(r,ms))}

    async function stepMove(){
      const next = {r:pos.r + (dir===1? -1: dir===3? 1: 0), c:pos.c + (dir===0? 1: dir===2? -1: 0)};
      if(next.r<0||next.c<0||next.r>=ROWS||next.c>=COLS||mask[next.r][next.c]===1){
        // bump anim
        heroEl.style.transform += ' translateY(-4px)';
        await sleep(120);
        heroEl.style.transform = heroEl.style.transform.replace(' translateY(-4px)','');
        return false;
      }
      heroEl.classList.add('run');
      pos = next;
      placeAt(heroEl, pos.r, pos.c);
      await sleep(220);
      heroEl.classList.remove('run');
      if(pos.r===goal.r && pos.c===goal.c){ alert('ðŸŽ‰ Berhasil!'); }
      return true;
    }

    function turnLeft(){ dir = (dir+3)%4; heroEl.style.rotate = (-(dir)*90)+'deg'; }
    function turnRight(){ dir = (dir+1)%4; heroEl.style.rotate = (-(dir)*90)+'deg'; }

    document.getElementById('btnReset').onclick = ()=>{ pos={...start}; dir=0; heroEl.style.rotate='0deg'; placeAt(heroEl,pos.r,pos.c); };
    document.getElementById('btnStep').onclick = ()=> stepMove();
    document.getElementById('btnRun').onclick = ()=> stepMove();
    document.getElementById('btnPlaySide').onclick = ()=> stepMove();

    // Reposition on resize
    addEventListener('resize', ()=>{ sizeSeaCanvas(); drawBoard(); sprinkleDeco(); placeAt(heroEl,pos.r,pos.c); placeAt(goalEl,goal.r,goal.c); });
  </script>
</body>
</html>
