<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KinderCoder – GameVP4</title>
  <script src="https://unpkg.com/blockly/blockly.min.js"></script>
  <script src="https://unpkg.com/blockly/msg/id.js"></script>
  <!-- Terrain Engine & Atlas -->
  <script src="/elearn/models/ts-fp/Terrain/js/terrain-atlas.js"></script>
  <script src="/elearn/models/ts-fp/Terrain/js/auto-tiler.js"></script>
  <script src="/elearn/models/ts-fp/Terrain/js/terrain-engine.js"></script>
  <style>
    :root{
      --bg:#131822; --panel:#0f1520; --panel-2:#111827; --text:#e6edf3; --muted:#9aa4b2;
      --accent:#22c55e; --accent-2:#f97316; --warn:#ef4444; --tile:#cf6f3b; --tile-2:#e19a60;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font:500 16px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial}
    .wrap{display:grid;grid-template-columns: 360px 1fr;gap:16px;height:100vh;padding:16px;box-sizing:border-box}
    /* Left – blocks */
    .left{background:linear-gradient(180deg,#0f172a 0%, #0b1220 100%);border-radius:16px;overflow:auto;display:flex;flex-direction:column;min-height:0}
    .left h3{margin:0;padding:14px 16px;background:#0b1220;border-bottom:1px solid #1f2937;font-size:15px;letter-spacing:.2px}
    .palette{padding:12px 12px 16px;display:flex;flex-wrap:wrap;gap:8px;align-content:flex-start}
    .workspace{flex:1; min-height:0; overflow:hidden; padding:0; background:#0e1525;}
    .section-title{width:100%;margin:6px 4px 2px;color:var(--muted);font-size:12px;text-transform:uppercase;letter-spacing:.12em}
    /* Hide legacy drag-drop UI (replaced by Blockly) */
    .palette, .program{ display:none; }

    .block{user-select:none;cursor:grab;background:#4c1d95;color:#fff;border-radius:10px;padding:10px 12px;box-shadow:0 8px 18px rgba(0,0,0,.25);position:relative}
    .block[data-type="move"]{background:#6d28d9}
    .block[data-type="left"]{background:#7c3aed}
    .block[data-type="right"]{background:#8b5cf6}
    .block.dragging{opacity:.7}

    .workspace .placeholder{border:2px dashed #334155;border-radius:10px;padding:12px;min-width:140px;height:40px;display:flex;align-items:center;justify-content:center;color:#64748b}
    .program{background:#0b1220;border:1px solid #243041;border-radius:12px;padding:10px}
    .hat{display:inline-block;background:#f97316;color:#fff;font-weight:800;border-radius:8px;padding:6px 10px;margin-bottom:8px}
    .stack{min-height:160px;background:#0e1525;border-radius:12px;padding:10px;position:relative}
    .stack .placeholder{background:transparent;border:2px dashed #334155;color:#64748b}

    /* Puzzle-like connectors */
    .block{margin:8px 0;position:relative}
    .block + .block{margin-top:12px}
    .block::after{content:"";position:absolute;left:16px;top:-6px;width:28px;height:10px;background:#0e1525;border-bottom-left-radius:6px;border-bottom-right-radius:6px}
    .block::before{content:"";position:absolute;left:16px;bottom:-6px;width:28px;height:10px;background:#0e1525;border-top-left-radius:6px;border-top-right-radius:6px}

    .row-controls{position:sticky;bottom:0;z-index:10;display:flex;align-items:center;gap:10px;padding:10px 12px;border-top:1px solid #1f2937;background:#0b1220}
    .btn{appearance:none;border:0;border-radius:12px;padding:10px 14px;font-weight:700;color:#0b1220;background:#22c55e;cursor:pointer}
    .btn.secondary{background:#334155;color:#e5e7eb}
    .btn.warn{background:#ef4444;color:#fff}
    .badge{margin-left:auto;background:#1f2937;color:#a3a3a3;border-radius:10px;padding:8px 10px;font-size:12px}
    .trash{margin:8px 12px 16px;background:#0e1525;border:2px dashed #334155;border-radius:12px;display:flex;align-items:center;gap:10px;justify-content:center;padding:10px;min-height:64px;transition:.15s;border-style:dashed;color:#94a3b8}
    .trash svg{width:28px;height:28px}
    .trash.active{border-color:#ef4444;background:#180f11;color:#fecaca}

    /* Right – board */
    .right{position:relative;background:#1e3a8a;border-radius:16px;overflow:hidden;display:grid;grid-template-rows: 1fr auto}

    .right .water-bg{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit:cover; object-position:center;
      z-index:0; pointer-events:none;
    }

    .board-wrap{display:flex;align-items:center;justify-content:center;padding:24px}
    .board{position:relative;width:520px;aspect-ratio: 1.2 / 1; background:transparent}
    .grid{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:320px;height:240px;display:grid;grid-template-columns:repeat(4,1fr);grid-template-rows:repeat(3,1fr);gap:4px;z-index:2;}
    .cell{background:var(--tile);border-radius:6px;box-shadow:inset 0 -4px 0 rgba(0,0,0,.2)}
    .cell.goal{background:var(--tile-2);position:relative}
    .cell.goal::after{content:"✖";position:absolute;inset:0;display:grid;place-items:center;font-size:28px;color:#ffedd5}
.deco{position:absolute;right:-8px;top:-8px;width:96px;height:72px;border-radius:10px;pointer-events:none;z-index:4;}
    .deco svg{width:100%;height:100%;filter:drop-shadow(0 10px 18px rgba(0,0,0,.35))}

    .robot{position:absolute;transition:transform .28s ease; width:52px;height:52px;display:grid;place-items:center;z-index:3;}
    .robot svg{width:52px;height:52px;filter:drop-shadow(0 6px 12px rgba(0,0,0,.5))}

    .hud{display:flex;align-items:center;gap:12px;padding:14px 16px;border-top:1px solid #1f2937;background:#0b1220}
    .hud .play{margin-left:auto}

    /* Tooltip / toast */
    .toast{position:fixed;left:50%;bottom:20px;transform:translateX(-50%) translateY(20px);background:#111827;color:#e5e7eb;border:1px solid #1f2937;border-radius:12px;padding:10px 14px;opacity:0;transition:.28s ease;pointer-events:none}
    .toast.show{opacity:1;transform:translateX(-50%) translateY(0)}
    .success{color:#10b981}
    .fail{color:#f87171}

    /* ===== Blockly Clay Style (neumorphism) ===== */
    /* Workspace bg */
    .blocklySvg { background: #eef2f6 !important; }
    .blocklyMainBackground{ stroke:#d4dbe5 !important; }
    /* Block surfaces */
    .blocklyBlockBackground{
      rx:12; ry:12;
      filter: drop-shadow(4px 6px 10px rgba(0,0,0,0.18))
              drop-shadow(-2px -2px 6px rgba(255,255,255,0.85));
    }
    /* Toolbox clay card look */
    .blocklyToolboxDiv{ background:#f3f6fb !important; border-right:1px solid #e2e8f0; }
    .blocklyTreeRow{ margin:6px 8px; border-radius:12px; padding:10px 14px; background:#fff !important;
      box-shadow: inset 2px 2px 4px rgba(0,0,0,.06), inset -2px -2px 4px rgba(255,255,255,.8); }
    .blocklyTreeRow:hover{ transform:translateY(-1px); box-shadow: 0 6px 14px rgba(0,0,0,.12); }
    .blocklyTreeLabel{ color:#111827 !important; font-weight:600; }
    .blocklyTreeSelected .blocklyTreeLabel{ color:#0f172a !important; }
    .blocklyFlyoutBackground{ fill:#f8fafc !important; }
    .blocklyFlyoutLabelText{ fill:#475569 !important; }
    /* Zoom controls & trash soft shadow */
    .blocklyZoom{
      filter: drop-shadow(2px 4px 6px rgba(0,0,0,.2));
    }
    /* ===== Top Slides Bar ===== */
    .top-slides{position:absolute;top:10px;left:50%;transform:translateX(-50%);display:flex;gap:8px;z-index:1000;background:rgba(11,18,32,.75);backdrop-filter:blur(6px);border:1px solid #1f2937;padding:8px 12px;border-radius:999px}
    .slide-dot{width:28px;height:28px;border-radius:50%;display:grid;place-items:center;font-weight:800;font-size:12px;color:#0b1220;background:#22c55e;cursor:pointer;user-select:none}
    .slide-dot.inactive{background:#334155;color:#e5e7eb}
    .slide-dot:active{transform:translateY(1px)}

    /* ===== Right Side Play Menu ===== */
    .side-play{position:fixed;right:18px;top:50%;transform:translateY(-50%);z-index:999;display:flex;flex-direction:column;align-items:center;gap:8px}
    .side-play .big-play{width:72px;height:72px;border-radius:50%;border:0;background:#22c55e;color:#0b1220;font-size:28px;font-weight:900;display:grid;place-items:center;cursor:pointer;box-shadow:0 10px 24px rgba(0,0,0,.35)}
    .side-play .big-play:hover{filter:brightness(1.05)}
    .side-play .big-play:active{transform:scale(.98)}
    .side-play .tip{font-size:12px;color:#9aa4b2;background:#0b1220;border:1px solid #1f2937;padding:4px 8px;border-radius:8px}
  </style>
</head>
<body>

  <!-- Right-side play menu -->
  <aside class="side-play" aria-label="menu-main">
    <button class="big-play" id="btnPlaySide" title="Jalankan">▶</button>
    <div class="tip">Jalankan</div>
  </aside>
  <div class="wrap">
    <section class="left" aria-label="blok">
      <h3>Blok Perintah</h3>
      <div class="palette" id="palette">
        <div class="section-title">Tarik ke kanan</div>
        <div class="block" draggable="true" data-type="move">melangkah maju</div>
        <div class="block" draggable="true" data-type="left">Belok kiri ↺</div>
        <div class="block" draggable="true" data-type="right">Belok kanan ↻</div>
      </div>
      <div class="section-title" style="padding:0 12px">Program Anda</div>
      <div class="workspace" id="workspace" aria-label="workspace">
        <!-- Blockly workspace -->
        <div id="blocklyDiv" style="width:100%; height:100%;"></div>
        <div class="program" id="program">
          <div class="hat">Ketika "Jalankan" diklik</div>
          <div class="stack" id="stack"><div class="placeholder">Taruh blok di sini…</div></div>
        </div>
      </div>
      <div class="row-controls">
        <button class="btn" id="btnRun">Jalankan</button>
        <button class="btn secondary" id="btnStep">Langkah</button>
        <button class="btn secondary" id="btnReset">Reset</button>
        <button class="btn warn" id="btnClear">Hapus semua</button>
        <div class="badge"><span id="blockCount">0</span> blok digunakan</div>
      </div>
    </section>

    <section class="right" aria-label="papan">
      <img class="water-bg" src="/elearn/models/ts-fp/Terrain/Water%20Background%20color.png" alt="">
      <!-- Top slides: 1..12 (centered to right panel) -->
      <nav class="top-slides" aria-label="slides">
        <div class="slide-dot">1</div>
        <div class="slide-dot">2</div>
        <div class="slide-dot">3</div>
        <div class="slide-dot">4</div>
        <div class="slide-dot">5</div>
        <div class="slide-dot">6</div>
        <div class="slide-dot">7</div>
        <div class="slide-dot">8</div>
        <div class="slide-dot">9</div>
        <div class="slide-dot">10</div>
        <div class="slide-dot">11</div>
        <div class="slide-dot">12</div>
      </nav>
      <div class="board-wrap">
        <div class="board">
          <!-- MINI TERRAIN RENDER (hanya tampilan; tanpa paint mode) -->
          <canvas id="terrainMini" width="320" height="240" style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);image-rendering:pixelated"></canvas>

          <canvas id="overlaySprites" style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);image-rendering:pixelated;pointer-events:none"></canvas>
          
          <div class="robot" id="robot" style="--r:0;">
            <!-- simple robot svg -->
            <svg viewBox="0 0 80 80" fill="none" xmlns="http://www.w3.org/2000/svg">
              <rect x="18" y="18" width="44" height="44" rx="12" fill="#ffcc66"/>
              <circle cx="36" cy="38" r="6" fill="#fff"/>
              <circle cx="36" cy="38" r="3" fill="#111"/>
              <circle cx="50" cy="38" r="6" fill="#fff"/>
              <circle cx="50" cy="38" r="3" fill="#111"/>
              <rect x="28" y="52" width="24" height="5" rx="2.5" fill="#111" opacity=".35"/>
              <path d="M16 42 q-6 4 0 9" stroke="#111" stroke-width="5" stroke-linecap="round"/>
            </svg>
          </div>
        </div>
      </div>
      <div class="hud">
        <div>Tujuan: pindahkan robot ke kotak ✖</div>
      </div>
    </section>
  </div>

  <div class="toast" id="toast"></div>

<script>
  (function(){
  // --- MINI TERRAIN RENDERER (pakai TerrainEngine & Atlas) ---
  const CANVAS = document.getElementById('terrainMini');
  let ROWS = 8, COLS = 8; // can be overridden by map json
  // Start & Goal
  const start = { r: 3, c: 0 };
  const goal  = { r: 3, c: 3 };

  // Setup TerrainEngine (defensive loader)
  let terrainEngine, tileSize;
  function drawFallback(){
    // simple grey board so layar tidak kosong kalau engine belum siap
    const ctx = CANVAS.getContext('2d');
    const w = CANVAS.width, h = CANVAS.height;
    const cellW = Math.floor(w / COLS), cellH = Math.floor(h / ROWS);
    ctx.clearRect(0,0,w,h);
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        ctx.fillStyle = '#223047';
        ctx.fillRect(c*cellW, r*cellH, cellW-1, cellH-1);
      }
    }
    // goal sign
    ctx.fillStyle = 'rgba(0,0,0,.18)';
    ctx.fillRect(goal.c*cellW, goal.r*cellH, cellW, cellH);
    ctx.fillStyle = '#ffedd5';
    ctx.font = `${Math.floor(cellH*0.6)}px system-ui`;
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('✖', goal.c*cellW + cellW/2, goal.r*cellH + cellH/2);
  }
  function setupTerrainMini(){
    if(!(window.TerrainAtlas && window.TerrainEngine)){
      console.warn('[GameVP4] Terrain scripts belum ter-load. Cek path /elearn/models/ts-fp/Terrain/js/*.js');
      drawFallback();
      return;
    }

    // Lokasi JSON atlas & layers (sesuaikan jika berbeda dengan terrain.html kamu)
    const ATLAS_JSON  = '/elearn/models/ts-fp/Terrain/atlas/terrain-atlas.json';
    const LAYERS_JSON = '/elearn/models/ts-fp/Terrain/atlas/terrain-layers.json';

    (async () => {
      try {
        // 1) Preload atlas untuk mendapatkan tileSize & set variant default
        const atlasJson = await TerrainAtlas.load(ATLAS_JSON);
        await TerrainAtlas.setVariant(atlasJson.defaultVariant || 'color1');
        const cfg = TerrainAtlas.getConfig();
        const t = cfg.tileSize || 64;

        // Try external map json for no-code island layout
        const qs = new URLSearchParams(location.search);
        const mapName = qs.get('map') || 'island1.json';
        let map = null;
        try{
          const res = await fetch('/elearn/worlds/kindercoder/maps/' + mapName, {cache:'no-cache'});
          if(res.ok) map = await res.json();
        }catch(_){}

        if(map && Number.isFinite(map.cols) && Number.isFinite(map.rows)){
          COLS = map.cols; ROWS = map.rows;
        }

        CANVAS.width  = COLS * t;
        CANVAS.height = ROWS * t;

        await TerrainEngine.init({
          atlasUrl: ATLAS_JSON,
          layersUrl: LAYERS_JSON,
          variant: (map && map.variant) || atlasJson.defaultVariant || 'color1',
          canvas: CANVAS
        });

        tileSize = t;

        // Optional: tiled water background texture
        try{ await TerrainEngine.setWaterTexture('/elearn/models/ts-fp/Terrain/Water%20Background%20color.png'); }catch(_){ }

        // Build grids either from map json or fallback to a handcrafted island
        const g  = TerrainEngine.getGrid('ground');
        const w  = TerrainEngine.getGrid('water');
        const cl = TerrainEngine.getGrid('cliff_land');
        const cl2= TerrainEngine.getGrid('cliff_land2');
        const cw = TerrainEngine.getGrid('cliff_water');
        const sl = TerrainEngine.getGrid('slopes');

        function applyMask(grid, mask){
          if(!grid || !mask) return;
          for(let r=0;r<ROWS;r++){
            for(let c=0;c<COLS;c++){
              const bit = mask[r]?.charAt(c) === '1' ? 1 : 0;
              grid[r][c] = bit;
            }
          }
        }

        if(map && map.layers){
          applyMask(w,  map.layers.water);
          applyMask(g,  map.layers.ground);
          applyMask(cl, map.layers.cliff_land);
          applyMask(cw, map.layers.cliff_water);
          applyMask(cl2, map.layers.cliff_land2);
          applyMask(sl, map.layers.slopes);
          if(g)  TerrainEngine.setGrid('ground', g);
          if(w)  TerrainEngine.setGrid('water', w);
          if(cl) TerrainEngine.setGrid('cliff_land', cl);
          if(cl2)TerrainEngine.setGrid('cliff_land2', cl2);
          if(cw) TerrainEngine.setGrid('cliff_water', cw);
          if(sl) TerrainEngine.setGrid('slopes', sl);
        } else {
          // --- Fallback handcrafted layout (8x8) with plateau, stairs, and small islets ---
          const G = [
            '01111000',
            '01111100',
            '11111100',
            '11101110',
            '11101110',
            '01111110',
            '00111100',
            '00010000'
          ];
          const CL = [
            '00111000',
            '00111000',
            '00000000',
            '00001000',
            '00000000',
            '00000000',
            '00000000',
            '00000000'
          ];
          const CW = [
            '00000000',
            '00000000',
            '00000000',
            '00000010',
            '00000000',
            '00000000',
            '00000110',
            '00000000'
          ];
          const SL = [
            '00000000',
            '00000000',
            '00000000',
            '00001000',
            '00000000',
            '00000100',
            '00000000',
            '00000000'
          ];
          // Fill water everywhere then carve ground/cliffs
          for(let r=0;r<ROWS;r++){ for(let c=0;c<COLS;c++){ if(w&&w[r]) w[r][c]=1; if(g&&g[r]) g[r][c]=0; if(cl&&cl[r]) cl[r][c]=0; if(cw&&cw[r]) cw[r][c]=0; if(sl&&sl[r]) sl[r][c]=0; } }
          applyMask(g, G); applyMask(cl, CL); applyMask(cw, CW); applyMask(sl, SL);
          if(g)  TerrainEngine.setGrid('ground', g);
          if(w)  TerrainEngine.setGrid('water', w);
          if(cl) TerrainEngine.setGrid('cliff_land', cl);
          if(cl2)TerrainEngine.setGrid('cliff_land2', cl2);
          if(cw) TerrainEngine.setGrid('cliff_water', cw);
          if(sl) TerrainEngine.setGrid('slopes', sl);
        }

        // Render + posisikan robot
        TerrainEngine.render();
        placeRobot();
      } catch (e){
        console.error('[GameVP4] setupTerrainMini error:', e);
        drawFallback();
      }
    })();
  }
  // Poll sampai ready (maks 2 detik)
  (function waitForTerrain(maxTry=20){
    if(window.TerrainAtlas && window.TerrainEngine){ setupTerrainMini(); return; }
    if(maxTry<=0){ setupTerrainMini(); return; } // akan gambar fallback + warning
    setTimeout(()=>waitForTerrain(maxTry-1), 100);
  })();

  // Walkability: check ground, water, cliff_land using TerrainEngine layers
  function isWalkable(r, c, fromDir) {
    // Saat engine belum siap (fallback) → izinkan selama masih di papan
    if (!(window.TerrainEngine && TerrainEngine.getGrid)) {
      return r>=0 && c>=0 && r<ROWS && c<COLS;
    }
    if (r < 0 || c < 0 || r >= ROWS || c >= COLS) return false;

    const g  = TerrainEngine.getGrid('ground');
    const w  = TerrainEngine.getGrid('water');
    const cl = TerrainEngine.getGrid('cliff_land');
    const cl2= TerrainEngine.getGrid('cliff_land2');
    const cw = TerrainEngine.getGrid('cliff_water');
    const sl = TerrainEngine.getGrid('slopes');

    const val = (grid, rr, cc) => (grid && grid[rr] ? (grid[rr][cc] ? 1 : 0) : 0);
    const levelAt = (rr, cc) => {
      const base = val(g, rr, cc) ? 1 : (val(cw, rr, cc) ? 1 : 0);
      return base + val(cl, rr, cc) + val(cl2, rr, cc);
    };
    const hereLvl = levelAt(pos.r, pos.c);
    const thereLvl = levelAt(r, c);
    if (thereLvl <= 0) return false; // water/void
    const delta = thereLvl - hereLvl;
    if (Math.abs(delta) === 0) return true;
    if (Math.abs(delta) > 1) return false; // too steep
    // Require slopes at source or target cell to change elevation
    const slopeHere = val(sl, pos.r, pos.c) === 1;
    const slopeThere = val(sl, r, c) === 1;
    return slopeHere || slopeThere;
  }

  // --- Robot state ---
  const robot = document.getElementById('robot');
  let dir = 0; // 0:right, 1:down, 2:left, 3:up
  let pos = {r:start.r, c:start.c};

  function placeRobot(){
    // Use tileSize from TerrainAtlas if available
    const tsize = (typeof tileSize === "number") ? tileSize : 80;
    const canvasBB = CANVAS.getBoundingClientRect();
    const boardBB  = robot.parentElement.getBoundingClientRect();
    const x = (canvasBB.left - boardBB.left) + pos.c * tsize + tsize/2 - 26;
    const y = (canvasBB.top  - boardBB.top)  + pos.r * tsize + tsize/2 - 26;
    robot.style.transform = `translate(${x}px, ${y}px) rotate(${dir*90}deg)`;
    // Notify overlay listeners to sync warrior position (center of tile)
    const centerX = (canvasBB.left - boardBB.left) + pos.c * tsize + tsize/2;
    const centerY = (canvasBB.top  - boardBB.top)  + pos.r * tsize + tsize/2;
    window.dispatchEvent(new CustomEvent('gvp4:place', { detail:{ r:pos.r, c:pos.c, dir, tileSize:tsize, x:centerX, y:centerY } }));
  }
  // Allow external listeners to request current placement broadcast
  window.addEventListener('gvp4:requestPlace', ()=>{ placeRobot(); });
  window.addEventListener('resize', placeRobot);
  setTimeout(placeRobot, 0);

  // --- Blocks drag & program ---
  const palette = document.getElementById('palette');
  const workspace = document.getElementById('workspace');
  const stack = document.getElementById('stack');
  const blockCount = document.getElementById('blockCount');
  const toast = document.getElementById('toast');
  const trash = document.getElementById('trash');

  // Step-by-step state
  let blocksCache = [];
  let pc = 0;            // program counter
  let hasStarted = false; // whether stepping has begun
  let draggingEl = null; // current block dragged from stack

  // === Blockly integration ===
  // Define Clay Theme (pastel colors and readable toolbox)
  const ClayTheme = Blockly.Theme.defineTheme('clay', {
    'base': Blockly.Themes.Classic,
    'blockStyles': {
      'robot_blocks': {
        'colourPrimary': '#8b9bff',
        'colourSecondary': '#6b7ae6',
        'colourTertiary': '#4d5cc7'
      },
      'control_blocks': {
        'colourPrimary': '#ffb86b',
        'colourSecondary': '#e89b4a',
        'colourTertiary': '#cc7f2f'
      }
    },
    'categoryStyles': {
      'robot_category': {'colour': '#8b9bff'},
      'control_category': {'colour': '#ffb86b'}
    },
    'componentStyles': {
      'workspaceBackgroundColour': '#eef2f6',
      'toolboxBackgroundColour': '#f3f6fb',
      'toolboxForegroundColour': '#111827',
      'flyoutBackgroundColour': '#f8fafc',
      'flyoutForegroundColour': '#334155',
      'flyoutOpacity': 1,
      'scrollbarColour': '#cbd5e1',
      'insertionMarkerColour': '#94a3b8',
      'insertionMarkerOpacity': 0.6
    }
  });
  let ws; // Blockly workspace

  // Minimal toolbox for robot
  const toolbox = {
    "kind":"categoryToolbox",
    "contents":[
      {"kind":"category","name":"Gerak","categorystyle":"robot_category","contents":[
        {"kind":"block","type":"robot_move"},
        {"kind":"block","type":"robot_turn"}
      ]},
      {"kind":"category","name":"Kontrol","categorystyle":"control_category","contents":[
        {"kind":"block","type":"robot_repeat"}
      ]}
    ]
  };

  // Define custom robot blocks
  Blockly.defineBlocksWithJsonArray([
    {"type":"robot_move","message0":"melangkah maju","previousStatement":null,"nextStatement":null,"style":"robot_blocks"},
    {"type":"robot_turn","message0":"belok %1","args0":[{"type":"field_dropdown","name":"DIR","options":[["kiri ↺","LEFT"],["kanan ↻","RIGHT"]]}],"previousStatement":null,"nextStatement":null,"style":"robot_blocks"},
    {"type":"robot_repeat","message0":"ulangi %1 kali %2",
      "args0":[{"type":"field_number","name":"TIMES","value":2,"min":1,"max":20},{"type":"input_statement","name":"DO"}],
      "previousStatement":null,"nextStatement":null,"style":"control_blocks"}
  ]);

  function initBlockly(){
    const host = document.getElementById('blocklyDiv');
    if(!host || typeof Blockly==='undefined') return;
    ws = Blockly.inject(host, {
      toolbox,
      theme: ClayTheme,
      trashcan: true,
      scrollbars: true,
      zoom: {controls:true, wheel:true, startScale:1, maxScale:2, minScale:.5}
    });
    window.addEventListener('resize', ()=>Blockly.svgResize(ws));
    setTimeout(()=>Blockly.svgResize(ws),0);
  }

  // Convert Blockly chains → array of robot commands (strings)
  function programFromBlockly(){
    const out = [];
    if(!ws) return out;
    const tops = ws.getTopBlocks(true);
    for(const t of tops){ collect(t, out); }
    return out;

    function collect(block, arr){
      if(!block) return;
      switch(block.type){
        case 'robot_move': arr.push('move'); break;
        case 'robot_turn': {
          const d = (block.getFieldValue('DIR')||'LEFT');
          arr.push(d === 'LEFT' ? 'left' : 'right');
          break;
        }
        case 'robot_repeat': {
          const n = parseInt(block.getFieldValue('TIMES')||1,10);
          const inner = block.getInputTargetBlock('DO');
          for(let i=0;i<n;i++) collect(inner, arr);
          break;
        }
      }
      const next = block.getNextBlock();
      if(next) collect(next, arr);
    }
  }

  function loadProgram(){
    blocksCache = programFromBlockly();
  }

  function showToast(msg, type){
    toast.textContent = msg;
    toast.className = 'toast show' + (type? ' ' + type : '');
    setTimeout(()=>toast.className='toast', 1600);
  }

  function updateCounter(){
    const used = stack.querySelectorAll('.block').length;
    blockCount.textContent = used;
    stack.querySelector('.placeholder')?.remove();
    if(used===0){
      const ph = document.createElement('div');
      ph.className='placeholder'; ph.textContent='Taruh blok di sini…';
      stack.appendChild(ph);
    }
    // refresh program + reset step state on any change
    loadProgram();
    pc = 0;
    hasStarted = false;
  }

  // Make palette blocks clonable on drag
  palette.addEventListener('dragstart', e=>{
    const b = e.target.closest('.block');
    if(!b) return;
    e.dataTransfer.setData('text/plain', b.dataset.type);
    b.classList.add('dragging');
  });
  palette.addEventListener('dragend', e=>{
    e.target.classList.remove('dragging');
  });

  stack.addEventListener('dragover', e=>{ e.preventDefault(); });
  stack.addEventListener('drop', e=>{
    e.preventDefault();
    const type = e.dataTransfer.getData('text/plain');
    if(!type) return;
    const nb = document.createElement('div');
    nb.className = 'block';
    nb.draggable = true;
    nb.dataset.type = type;
    nb.textContent = type==='move' ? 'melangkah maju' : (type==='left' ? 'Belok kiri ↺' : 'Belok kanan ↻');
    stack.appendChild(nb);
    updateCounter();
  });

  // Allow re-order & deletion (double click)
  stack.addEventListener('dragstart', e=>{
    const b = e.target.closest('.block');
    if(!b) return; e.dataTransfer.setData('text/plain', 'reorder');
    e.dataTransfer.setDragImage(b, 20, 20);
    b.classList.add('dragging');
    draggingEl = b;
  });
  stack.addEventListener('dragend', e=>{ e.target.classList.remove('dragging'); draggingEl = null; updateCounter(); });
  // Trash dropzone (optional): only if element exists
  if(trash){
    ['dragenter','dragover'].forEach(ev=> trash.addEventListener(ev, e=>{ e.preventDefault(); trash.classList.add('active'); }));
    ['dragleave','drop'].forEach(ev=> trash.addEventListener(ev, e=>{ trash.classList.remove('active'); }));
    trash.addEventListener('drop', e=>{
      e.preventDefault();
      const kind = e.dataTransfer.getData('text/plain');
      if(kind === 'reorder' && draggingEl){ draggingEl.remove(); updateCounter(); showToast('Blok dihapus.'); }
    });
  }
  stack.addEventListener('dragover', e=>{
    const dragging = stack.querySelector('.block.dragging');
    if(!dragging) return;
    const after = Array.from(stack.querySelectorAll('.block:not(.dragging)'))
      .find(el => e.clientX <= el.getBoundingClientRect().left + el.offsetWidth/2);
    if(after) stack.insertBefore(dragging, after); else stack.appendChild(dragging);
  });
  stack.addEventListener('dblclick', e=>{
    const b = e.target.closest('.block');
    if(!b) return; b.remove(); updateCounter();
  });

  // Controls
  document.getElementById('btnClear').onclick = ()=>{ stack.innerHTML = ''; updateCounter(); };

  document.getElementById('btnStep').onclick = ()=>{ stepOnce(); };
  document.getElementById('btnReset').onclick = ()=>{ pc = 0; hasStarted = false; pos = {r:start.r, c:start.c}; dir = 0; placeRobot(); showToast('Diulang dari awal.'); };
  document.getElementById('btnRun').onclick = ()=>{ runProgram(); };
  const btnPlaySide = document.getElementById('btnPlaySide');
  if(btnPlaySide){ btnPlaySide.onclick = ()=>{ runProgram(); }; }

  // Program runner
  let running = false;
  async function runProgram(){
    if(running) return; running = true;
    // start from beginning for full run
    loadProgram();
    pos = {r:start.r, c:start.c}; dir = 0; placeRobot();
    pc = 0; hasStarted = true;
    if(blocksCache.length===0){ showToast('Tambahkan blok dulu, ya!', 'fail'); running=false; return; }

    for(let i=0;i<blocksCache.length;i++){
      const t = blocksCache[i];
      const ok = await exec(t);
      if(!ok){ showToast('Ups, menabrak dinding.', 'fail'); break; }
      pc++;
      if(pos.r===goal.r && pos.c===goal.c){ showToast('Mantap! Sampai tujuan ✔', 'success'); break; }
    }
    running = false;
  }

  async function stepOnce(){
    if(running) return;
    // ensure we have latest program cache
    if(blocksCache.length===0){ loadProgram(); }
    if(blocksCache.length===0){ showToast('Tambahkan blok dulu, ya!', 'fail'); return; }

    if(!hasStarted){ // first step: reset to start
      pos = {r:start.r, c:start.c}; dir = 0; placeRobot();
      hasStarted = true; pc = 0;
    }
    if(pc >= blocksCache.length){ showToast('Program selesai. Klik Reset untuk ulang.', 'fail'); return; }

    running = true;
    const ok = await exec(blocksCache[pc]);
    running = false;
    if(!ok){ showToast('Ups, menabrak dinding.', 'fail'); return; }

    pc++;
    if(pos.r===goal.r && pos.c===goal.c){ showToast('Mantap! Sampai tujuan ✔', 'success'); }
  }

  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
  async function exec(type){
    if(type==='left'){ dir = (dir+3)%4; placeRobot(); await sleep(220); return true; }
    if(type==='right'){ dir = (dir+1)%4; placeRobot(); await sleep(220); return true; }
    if(type==='move'){
      const next = {
        r: pos.r + (dir===1?1:dir===3?-1:0),
        c: pos.c + (dir===0?1:dir===2?-1:0)
      };

      // Cek batas atlas
      if(next.r<0 || next.c<0 || next.r>=ROWS || next.c>=COLS){
        robot.animate([{transform:robot.style.transform},
                       {transform:robot.style.transform+' translateY(-4px)'},
                       {transform:robot.style.transform}], {duration:220});
        await sleep(220); return false;
      }

      // Cek walkability berdasarkan jenis tile (ground/water/cliff/slope)
      if(!isWalkable(next.r, next.c, dir)){
        robot.animate([{transform:robot.style.transform},
                       {transform:robot.style.transform+' translateY(-4px)'},
                       {transform:robot.style.transform}], {duration:220});
        await sleep(220); return false;
      }

      // Announce start of movement for overlay animation (run)
      window.dispatchEvent(new CustomEvent('gvp4:moveStart', { detail:{ from:{...pos}, to:next, dir } }));
      pos = next; placeRobot();
      await sleep(260);
      window.dispatchEvent(new CustomEvent('gvp4:moveEnd', { detail:{ pos:{...pos}, dir } }));
      return true;
    }
    return true;
  }

  // (Optional visual state) Mark slide 1 as active and others inactive for now
  document.querySelectorAll('.top-slides .slide-dot').forEach((el,i)=>{
    if(i>0) el.classList.add('inactive');
  });
  initBlockly();
  updateCounter();
})();
</script>

<script type="module">
  import * as Assets from '/elearn/engine/assets-runtime.js';

  const terrain = document.getElementById('terrainMini');
  const overlay = document.getElementById('overlaySprites');
  function syncOverlaySize(){
    overlay.width = terrain.width; overlay.height = terrain.height;
    overlay.style.width = terrain.style.width; overlay.style.height = terrain.style.height;
  }
  syncOverlaySize(); new ResizeObserver(syncOverlaySize).observe(terrain);

  await Assets.init({ manifestUrl:'/elearn/assets/manifest.json', prewarm:['unit','building','decor'] });

  const scene = Assets.createScene(overlay);
  // Note: Remove sample spawns to avoid fallback red boxes when assets are missing
  // const gob = await Assets.spawn('goblin_scout', { x: 96, y: 96, state:{anim:'idle'} });
  // const castle = await Assets.spawn('castle_blue', { x: 240, y: 180 });
  // const trees = await Assets.spawn('forest_pack_a');
  // scene.add(gob, castle, trees);

  // --- Warrior overlay actor (uses PNG strips, not Aseprite JSON) ---
  const WARRIOR_BASE = '/elearn/models/ts-fp/Units/Blue Units/Warrior';
  const W_STATES = ['Idle','Run','Guard','Attack1','Attack2'];
  const W_FPS = { Idle:6, Run:12, Guard:8, Attack1:12, Attack2:12 };
  function inferMeta(img){
    let frames=1, fw=img.width, fh=img.height, vertical=false;
    if(img.width>img.height && img.width%img.height===0){ frames=img.width/img.height; fw=img.height; fh=img.height; }
    else if(img.height>img.width && img.height%img.width===0){ frames=img.height/img.width; fw=img.width; fh=img.width; vertical=true; }
    else{ for(let n=2;n<=16;n++){ if(img.width % n===0){ frames=n; fw=img.width/n; fh=img.height; break; } } }
    return {frames, fw, fh, vertical};
  }
  function loadImage(src){ return new Promise((res,rej)=>{ const im=new Image(); im.onload=()=>res(im); im.onerror=rej; im.src=src; }); }
  async function loadWarrior(){
    const cache=new Map();
    for(const s of W_STATES){
      try{ const img = await loadImage(`${WARRIOR_BASE}/Warrior_${s}.png`); cache.set(s,{img, ...inferMeta(img)}); }
      catch{ /* tolerate */ }
    }
    return cache;
  }
  const warrior = {
    cache: await loadWarrior(), x: 0, y: 0, state: 'Idle', t: 0, frameIdx:0, acc:0,
    update(dt){ this.t += dt; this.acc += dt; const fps=W_FPS[this.state]||10; const frameMs=1000/fps; const entry=this.cache.get(this.state)||this.cache.get('Idle'); if(!entry) return; while(this.acc>=frameMs){ this.acc-=frameMs; this.frameIdx=(this.frameIdx+1)%(entry.frames||1);} },
    draw(ctx){ const entry=this.cache.get(this.state)||this.cache.get('Idle'); if(!entry) return; const {img,frames,fw,fh,vertical}=entry; const idx=this.frameIdx%(frames||1); const sx=vertical?0:idx*fw; const sy=vertical?idx*fh:0; const scale=1; const dx=Math.round(this.x - fw*scale/2); const dy=Math.round(this.y - fh*scale); ctx.drawImage(img, sx, sy, fw, fh, dx, dy, fw*scale, fh*scale); }
  };
  scene.add(warrior);

  // Sync warrior with robot grid position via custom events from the non-module script
  window.addEventListener('gvp4:place', (e)=>{
    // e.detail contains center x,y computed in DOM space; we need canvas coords (overlay origin is the board's center canvas origin)
    // Because overlay is absolutely centered over terrain canvas and has identical pixel size, we can compute x,y based on tileSize and pos.
    const { r, c, tileSize } = e.detail || {};
    warrior.x = c * tileSize + tileSize/2;
    warrior.y = r * tileSize + tileSize/2;
  });
  window.addEventListener('gvp4:moveStart', ()=>{ warrior.state = 'Run'; warrior.acc=0; });
  window.addEventListener('gvp4:moveEnd',   ()=>{ warrior.state = 'Idle'; });

  // Hide original robot SVG (we draw warrior instead)
  const robotEl = document.getElementById('robot');
  if(robotEl) robotEl.style.display = 'none';

  // Ask for initial placement once listeners are ready
  window.dispatchEvent(new CustomEvent('gvp4:requestPlace'));

  scene.start();

  // Quick switch tileset variants with keys 1/2/3
  window.addEventListener('keydown', async (e)=>{
    if(e.key==='1'){ await TerrainEngine.setVariant('color1'); TerrainEngine.render(); }
    if(e.key==='2'){ await TerrainEngine.setVariant('color2'); TerrainEngine.render(); }
    if(e.key==='3'){ await TerrainEngine.setVariant('color3'); TerrainEngine.render(); }
  });
</script>
</body>
</html>
