<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KinderCoder â€“ GameVP4</title>
  <script src="https://unpkg.com/blockly/blockly.min.js"></script>
  <script src="https://unpkg.com/blockly/msg/id.js"></script>
  <!-- Terrain Engine & Atlas -->
  <script src="/elearn/models/ts-fp/Terrain/js/terrain-atlas.js"></script>
  <script src="/elearn/models/ts-fp/Terrain/js/auto-tiler.js"></script>
  <script src="/elearn/models/ts-fp/Terrain/js/terrain-engine.js"></script>
  <style>
    :root{
      --bg:#131822; --panel:#0f1520; --panel-2:#111827; --text:#e6edf3; --muted:#9aa4b2;
      --accent:#22c55e; --accent-2:#f97316; --warn:#ef4444; --tile:#cf6f3b; --tile-2:#e19a60;
      /* Cursor hotspot (px from top-left of image). Tweak here. */
      --cursor-x: 22;
      --cursor-y: 18;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font:500 16px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial;cursor:url('/elearn/models/ts-up/UI/Pointers/01.png') var(--cursor-x) var(--cursor-y), auto}
    .wrap{display:grid;grid-template-columns: 360px 1fr;gap:16px;height:100vh;padding:16px;box-sizing:border-box}
    /* Left â€“ blocks */
    .left{background:linear-gradient(180deg,#0f172a 0%, #0b1220 100%);border-radius:16px;overflow:auto;display:flex;flex-direction:column;min-height:0}
    .left h3{margin:0;padding:14px 16px;background:#0b1220;border-bottom:1px solid #1f2937;font-size:15px;letter-spacing:.2px}
    .palette{padding:12px 12px 16px;display:flex;flex-wrap:wrap;gap:8px;align-content:flex-start}
    .workspace{flex:1; min-height:0; overflow:hidden; padding:0; background:#0e1525;}
    .section-title{width:100%;margin:6px 4px 2px;color:var(--muted);font-size:12px;text-transform:uppercase;letter-spacing:.12em}
    /* Hide legacy drag-drop UI (replaced by Blockly) */
    .palette, .program{ display:none; }

    .block{user-select:none;cursor:grab;background:#4c1d95;color:#fff;border-radius:10px;padding:10px 12px;box-shadow:0 8px 18px rgba(0,0,0,.25);position:relative}
    .block[data-type="move"]{background:#6d28d9}
    .block[data-type="left"]{background:#7c3aed}
    .block[data-type="right"]{background:#8b5cf6}
    .block.dragging{opacity:.7}

    .workspace .placeholder{border:2px dashed #334155;border-radius:10px;padding:12px;min-width:140px;height:40px;display:flex;align-items:center;justify-content:center;color:#64748b}
    .program{background:#0b1220;border:1px solid #243041;border-radius:12px;padding:10px}
    .hat{display:inline-block;background:#f97316;color:#fff;font-weight:800;border-radius:8px;padding:6px 10px;margin-bottom:8px}
    .stack{min-height:160px;background:#0e1525;border-radius:12px;padding:10px;position:relative}
    .stack .placeholder{background:transparent;border:2px dashed #334155;color:#64748b}

    /* Puzzle-like connectors */
    .block{margin:8px 0;position:relative}
    .block + .block{margin-top:12px}
    .block::after{content:"";position:absolute;left:16px;top:-6px;width:28px;height:10px;background:#0e1525;border-bottom-left-radius:6px;border-bottom-right-radius:6px}
    .block::before{content:"";position:absolute;left:16px;bottom:-6px;width:28px;height:10px;background:#0e1525;border-top-left-radius:6px;border-top-right-radius:6px}

    .row-controls{position:sticky;bottom:0;z-index:10;display:flex;align-items:center;gap:10px;padding:10px 12px;border-top:1px solid #1f2937;background:#0b1220}
    .btn{appearance:none;border:0;border-radius:12px;padding:10px 14px;font-weight:700;color:#0b1220;background:#22c55e;cursor:pointer}
    .btn.secondary{background:#334155;color:#e5e7eb}
    .btn.warn{background:#ef4444;color:#fff}
    .badge{margin-left:auto;background:#1f2937;color:#a3a3a3;border-radius:10px;padding:8px 10px;font-size:12px}
    .trash{margin:8px 12px 16px;background:#0e1525;border:2px dashed #334155;border-radius:12px;display:flex;align-items:center;gap:10px;justify-content:center;padding:10px;min-height:64px;transition:.15s;border-style:dashed;color:#94a3b8}
    .trash svg{width:28px;height:28px}
    .trash.active{border-color:#ef4444;background:#180f11;color:#fecaca}

    /* Right â€“ board */
    .right{position:relative;background:#1e3a8a;border-radius:16px;overflow:hidden;display:grid;grid-template-rows: 1fr auto}
    .right, .board, canvas { cursor:url('/elearn/models/ts-up/UI/Pointers/01.png') var(--cursor-x) var(--cursor-y), auto }

    .right .water-bg{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit:cover; object-position:center;
      z-index:0; pointer-events:none;
    }

    /* Decorative sea strip on the left: ripples (+ optional clouds) */
    .sea-decor{position:absolute;left:0;top:0;height:100%;width:120px;pointer-events:none;z-index:1;overflow:hidden;}
    /* ripples layer using inline SVG pattern */
    .sea-decor::before{content:"";position:absolute;inset:0;opacity:.28; z-index:0;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='640' height='360' viewBox='0 0 640 360'%3E%3Cg fill='none' stroke-linecap='round'%3E%3Cpath d='M-40 30 C 40 10, 140 50, 240 30 S 440 10, 640 30' stroke='rgba(255,255,255,0.23)' stroke-width='2.5'/%3E%3Cpath d='M-60 70 C 30 45, 150 85, 260 70 S 470 45, 660 70' stroke='rgba(255,255,255,0.18)' stroke-width='1.2'/%3E%3Cpath d='M-50 115 C 60 95, 160 135, 300 120 S 520 95, 690 120' stroke='rgba(255,255,255,0.2)' stroke-width='1.4'/%3E%3Cpath d='M-30 160 C 80 140, 200 180, 340 165 S 560 140, 720 165' stroke='rgba(255,255,255,0.16)' stroke-width='1.1'/%3E%3Cpath d='M-70 210 C 20 185, 140 225, 260 210 S 480 185, 670 210' stroke='rgba(255,255,255,0.18)' stroke-width='1.3'/%3E%3Cpath d='M-40 255 C 100 235, 220 275, 360 255 S 580 235, 760 255' stroke='rgba(255,255,255,0.15)' stroke-width='1.2'/%3E%3Cpath d='M-50 305 C 60 285, 200 325, 340 305 S 560 285, 740 305' stroke='rgba(255,255,255,0.18)' stroke-width='1.2'/%3E%3C/g%3E%3C/svg%3E");
      background-size: 640px 360px; background-repeat: repeat; background-position: 0 0;
      animation: rippleShift 36s linear infinite;
    }
    @keyframes rippleShift{ 0%{ background-position:0 0;} 100%{ background-position:-640px 360px;} }
    /* second, larger/looser ripple layer for randomness */
    .sea-decor::after{content:"";position:absolute;inset:0;opacity:.20; z-index:0; pointer-events:none;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='960' height='540' viewBox='0 0 960 540'%3E%3Cg fill='none' stroke-linecap='round'%3E%3Cpath d='M-60 55 C 60 5, 240 85, 420 40 S 780 5, 1020 55' stroke='rgba(255,255,255,0.16)' stroke-width='2'/%3E%3Cpath d='M-80 145 C 80 100, 280 170, 500 130 S 900 100, 1100 145' stroke='rgba(255,255,255,0.14)' stroke-width='1.7'/%3E%3Cpath d='M-40 250 C 120 210, 340 280, 560 240 S 940 210, 1180 250' stroke='rgba(255,255,255,0.15)' stroke-width='1.8'/%3E%3C/svg%3E");
      background-size: 960px 540px; background-repeat: repeat; background-position: 0 0;
      animation: rippleShift2 48s linear infinite;
    }
    @keyframes rippleShift2{ 0%{ background-position:0 0;} 100%{ background-position:-960px 270px;} }
    /* cloud images from asset (no sea color overlay) */
    img.cloud{position:absolute;left:-80px;height:auto;filter: drop-shadow(0 6px 0 rgba(0,0,0,.18));opacity:.95;animation: floatX 26s ease-in-out infinite; z-index:1;}
    img.cloud.c1{top:10%; width:200px}
    img.cloud.c2{top:46%; width:220px; animation-duration: 34s;}
    img.cloud.c3{top:80%; width:190px; animation-duration: 28s;}
    @keyframes floatX{ 0%,100%{ transform: translateX(0) } 50%{ transform: translateX(6px) } }

    .board-wrap{display:flex;align-items:center;justify-content:center;padding:24px}
    .board{position:relative;width:520px;aspect-ratio: 1.2 / 1; background:transparent}
    .grid{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:320px;height:240px;display:grid;grid-template-columns:repeat(4,1fr);grid-template-rows:repeat(3,1fr);gap:4px;z-index:2;}
    .cell{background:var(--tile);border-radius:6px;box-shadow:inset 0 -4px 0 rgba(0,0,0,.2)}
    .cell.goal{background:var(--tile-2);position:relative}
    .cell.goal::after{content:"âœ–";position:absolute;inset:0;display:grid;place-items:center;font-size:28px;color:#ffedd5}
.deco{position:absolute;right:-8px;top:-8px;width:96px;height:72px;border-radius:10px;pointer-events:none;z-index:4;}
    .deco svg{width:100%;height:100%;filter:drop-shadow(0 10px 18px rgba(0,0,0,.35))}

    .robot{position:absolute;transition:transform .28s ease; width:52px;height:52px;display:grid;place-items:center;z-index:3;}
    .robot svg{width:52px;height:52px;filter:drop-shadow(0 6px 12px rgba(0,0,0,.5))}

    .hud{display:flex;align-items:center;gap:12px;padding:14px 16px;border-top:1px solid #1f2937;background:#0b1220}
    .hud .play{margin-left:auto}

    /* Tooltip / toast */
    .toast{position:fixed;left:50%;bottom:20px;transform:translateX(-50%) translateY(20px);background:#111827;color:#e5e7eb;border:1px solid #1f2937;border-radius:12px;padding:10px 14px;opacity:0;transition:.28s ease;pointer-events:none}
    .toast.show{opacity:1;transform:translateX(-50%) translateY(0)}
    .success{color:#10b981}
    .fail{color:#f87171}

    /* ===== Blockly Clay Style (neumorphism) ===== */
    /* Workspace bg */
    .blocklySvg { background: #eef2f6 !important; }
    .blocklyMainBackground{ stroke:#d4dbe5 !important; }
    /* Block surfaces */
    .blocklyBlockBackground{
      rx:12; ry:12;
      filter: drop-shadow(4px 6px 10px rgba(0,0,0,0.18))
              drop-shadow(-2px -2px 6px rgba(255,255,255,0.85));
    }
    /* Toolbox clay card look */
    .blocklyToolboxDiv{ background:#f3f6fb !important; border-right:1px solid #e2e8f0; }
    .blocklyTreeRow{ margin:6px 8px; border-radius:12px; padding:10px 14px; background:#fff !important;
      box-shadow: inset 2px 2px 4px rgba(0,0,0,.06), inset -2px -2px 4px rgba(255,255,255,.8); }
    .blocklyTreeRow:hover{ transform:translateY(-1px); box-shadow: 0 6px 14px rgba(0,0,0,.12); }
    .blocklyTreeLabel{ color:#111827 !important; font-weight:600; }
    .blocklyTreeSelected .blocklyTreeLabel{ color:#0f172a !important; }
    .blocklyFlyoutBackground{ fill:#f8fafc !important; }
    .blocklyFlyoutLabelText{ fill:#475569 !important; }
    /* Zoom controls & trash soft shadow */
    .blocklyZoom{
      filter: drop-shadow(2px 4px 6px rgba(0,0,0,.2));
    }
    /* ===== Top Slides Bar ===== */
    .top-slides{position:absolute;top:10px;left:50%;transform:translateX(-50%);display:flex;gap:8px;z-index:1000;background:rgba(11,18,32,.75);backdrop-filter:blur(6px);border:1px solid #1f2937;padding:8px 12px;border-radius:999px}
    .slide-dot{width:28px;height:28px;border-radius:50%;display:grid;place-items:center;font-weight:800;font-size:12px;color:#0b1220;background:#22c55e;cursor:pointer;user-select:none}
    .slide-dot.inactive{background:#334155;color:#e5e7eb}
    .slide-dot:active{transform:translateY(1px)}

    /* ===== Right Side Play Menu ===== */
    .side-play{position:fixed;right:18px;top:50%;transform:translateY(-50%);z-index:999;display:flex;flex-direction:column;align-items:center;gap:8px}
    .side-play .big-play{width:72px;height:72px;border-radius:50%;border:0;background:#22c55e;color:#0b1220;font-size:28px;font-weight:900;display:grid;place-items:center;cursor:pointer;box-shadow:0 10px 24px rgba(0,0,0,.35)}
    .side-play .big-play:hover{filter:brightness(1.05)}
    .side-play .big-play:active{transform:scale(.98)}
    .side-play .tip{font-size:12px;color:#9aa4b2;background:#0b1220;border:1px solid #1f2937;padding:4px 8px;border-radius:8px}
  </style>
</head>
<body>

  <!-- Right-side play menu -->
  <aside class="side-play" aria-label="menu-main">
    <button class="big-play" id="btnPlaySide" title="Jalankan">â–¶</button>
    <div class="tip">Jalankan</div>
  </aside>
  <div class="wrap">
    <section class="left" aria-label="blok">
      <h3>Blok Perintah</h3>
      <div class="palette" id="palette">
        <div class="section-title">Tarik ke kanan</div>
        <div class="block" draggable="true" data-type="move">melangkah maju</div>
        <div class="block" draggable="true" data-type="left">Belok kiri â†º</div>
        <div class="block" draggable="true" data-type="right">Belok kanan â†»</div>
      </div>
      <div class="section-title" style="padding:0 12px">Program Anda</div>
      <div class="workspace" id="workspace" aria-label="workspace">
        <!-- Blockly workspace -->
        <div id="blocklyDiv" style="width:100%; height:100%;"></div>
        <div class="program" id="program">
          <div class="hat">Ketika "Jalankan" diklik</div>
          <div class="stack" id="stack"><div class="placeholder">Taruh blok di siniâ€¦</div></div>
        </div>
      </div>
      <div class="row-controls">
        <button class="btn" id="btnRun">Jalankan</button>
        <button class="btn secondary" id="btnStep">Langkah</button>
        <button class="btn secondary" id="btnReset">Reset</button>
        <button class="btn warn" id="btnClear">Hapus semua</button>
        <div class="badge"><span id="blockCount">0</span> blok digunakan</div>
      </div>
    </section>

    <section class="right" aria-label="papan">
      <img class="water-bg" src="/elearn/models/ts-fp/Terrain/Water%20Background%20color.png" alt="">
      <div class="sea-decor">
        <img class="cloud c1" src="/elearn/models/ts-up/cloud1.png" alt="cloud1">
        <img class="cloud c2" src="/elearn/models/ts-up/cloud2.png" alt="cloud2">
        <img class="cloud c3" src="/elearn/models/ts-up/cloud3.png" alt="cloud3">
      </div>
      <!-- Top slides: 1..12 (centered to right panel) -->
      <nav class="top-slides" aria-label="slides">
        <div class="slide-dot">1</div>
        <div class="slide-dot">2</div>
        <div class="slide-dot">3</div>
        <div class="slide-dot">4</div>
        <div class="slide-dot">5</div>
        <div class="slide-dot">6</div>
        <div class="slide-dot">7</div>
        <div class="slide-dot">8</div>
        <div class="slide-dot">9</div>
        <div class="slide-dot">10</div>
        <div class="slide-dot">11</div>
        <div class="slide-dot">12</div>
      </nav>
      <div class="board-wrap">
        <div class="board">
          <!-- MINI TERRAIN RENDER (hanya tampilan; tanpa paint mode) -->
          <canvas id="terrainMini" width="320" height="240" style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);image-rendering:pixelated"></canvas>

          <canvas id="overlaySprites" style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);image-rendering:pixelated;pointer-events:none"></canvas>
          
          <!-- Robot SVG removed; warrior overlay is the only character renderer -->
        </div>
      </div>
      <div class="hud">
        <div>Tujuan: pindahkan robot ke kotak âœ–</div>
      </div>
    </section>
  </div>

  <div class="toast" id="toast"></div>

<script>
  (function(){
  // --- MINI TERRAIN RENDERER (pakai TerrainEngine & Atlas) ---
  const CANVAS = document.getElementById('terrainMini');
  // Slide handling (12 dots on top). Current slide from URL ?s=1..12
  const qs0 = new URLSearchParams(location.search);
  const SLIDE_MAX = 12;
  let curSlide = Math.max(1, Math.min(SLIDE_MAX, parseInt(qs0.get('s')||'1',10)||1));
  let ROWS = 8, COLS = 8; // can be overridden by map json
  // Start & Goal (will follow JSON or query; defaults only if missing)
  let start = { r: 0, c: 6 };
  let goal  = { r: 0, c: 0 };
  // Optional markers
  let checkpoints = [];
  let items = [];
  let obstacles = [];
  const visited = new Set();
  const collected = new Set();

  // Setup TerrainEngine (defensive loader)
  let terrainEngine, tileSize;
  function drawFallback(){
    // simple grey board so layar tidak kosong kalau engine belum siap
    const ctx = CANVAS.getContext('2d');
    const w = CANVAS.width, h = CANVAS.height;
    const cellW = Math.floor(w / COLS), cellH = Math.floor(h / ROWS);
    ctx.clearRect(0,0,w,h);
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        ctx.fillStyle = '#223047';
        ctx.fillRect(c*cellW, r*cellH, cellW-1, cellH-1);
      }
    }
    // goal sign (guard if goal not valid yet)
    if(goal && Number.isFinite(goal.r) && Number.isFinite(goal.c)){
      ctx.fillStyle = 'rgba(0,0,0,.18)';
      ctx.fillRect(goal.c*cellW, goal.r*cellH, cellW, cellH);
      ctx.fillStyle = '#ffedd5';
      ctx.font = `${Math.floor(cellH*0.6)}px system-ui`;
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText('âœ–', goal.c*cellW + cellW/2, goal.r*cellH + cellH/2);
    }
  }
  function setupTerrainMini(){
    if(!(window.TerrainAtlas && window.TerrainEngine)){
      console.warn('[GameVP4] Terrain scripts belum ter-load. Cek path /elearn/models/ts-fp/Terrain/js/*.js');
      drawFallback();
      return;
    }

    // Lokasi JSON atlas & layers (sesuaikan jika berbeda dengan terrain.html kamu)
    const ATLAS_JSON  = '/elearn/models/ts-fp/Terrain/atlas/terrain-atlas.json';
    const LAYERS_JSON = '/elearn/models/ts-fp/Terrain/atlas/terrain-layers.json';

    (async () => {
      try {
        // 1) Preload atlas untuk mendapatkan tileSize & set variant default
        const atlasJson = await TerrainAtlas.load(ATLAS_JSON);
        await TerrainAtlas.setVariant(atlasJson.defaultVariant || 'color1');
        const cfg = TerrainAtlas.getConfig();
        const t = cfg.tileSize || 64;
        // Expose tile size globally so placement and overlay can stay in sync
        tileSize = t; window.tileSize = t;

        // Try external map json for no-code island layout
        const qs = new URLSearchParams(location.search);
        // Default to an existing map file in repo
        const mapName = qs.get('map') || 'island.json';
        let map = null;
        try{
          const res = await fetch('/elearn/worlds/kindercoder/maps/' + mapName, {cache:'no-cache'});
          if(res.ok) map = await res.json();
        }catch(_){}

        if(map && Number.isFinite(map.cols) && Number.isFinite(map.rows)){
          COLS = map.cols; ROWS = map.rows;
        }

        // Allow custom start/goal from map JSON or URL query (?start=r,c&goal=r,c)
        function clampRC(p){
          if(!p) return null; const r = Math.max(0, Math.min(ROWS-1, p.r|0)); const c = Math.max(0, Math.min(COLS-1, p.c|0)); return {r,c};
        }
        function parseRC(s){ if(!s) return null; const a=s.split(',').map(x=>+x); if(a.length!==2||!a.every(Number.isFinite)) return null; return {r:a[0], c:a[1]}; }
        let mapStart = clampRC(map?.start);
        let mapGoal  = clampRC(map?.goal);
        const qsStart  = clampRC(parseRC(qs.get('start')));
        const qsGoal   = clampRC(parseRC(qs.get('goal')));
        if(qsStart) start = qsStart; else if(mapStart) start = mapStart; else start = start || { r: 0, c: 0 };
        if(qsGoal)  goal  = qsGoal;  else if(mapGoal)  goal  = mapGoal;  else goal  = goal  || { r: Math.min(ROWS-1, 3), c: Math.min(COLS-1, 3) };

        // Optional: per-slide preset ONLY if explicitly requested via ?preset=1
        // Preserve existing start/goal (map or defaults) by default.
        if (!qsStart && !qsGoal && String(qs.get('preset')) === '1') {
          const preset = levelPreset(curSlide, ROWS, COLS);
          if (preset && preset.start && preset.goal) { start = preset.start; goal = preset.goal; }
        }

        // Sync internal robot position to map start so initial placement matches JSON
        if (start && Number.isFinite(start.r) && Number.isFinite(start.c)) {
          pos = { r: start.r, c: start.c };
        }
        // Clamp only (JSON already uses 0-based r,c like the engine)
        const adj = (p)=> ({ r: Math.max(0, Math.min(ROWS-1, (p.r|0))), c: Math.max(0, Math.min(COLS-1, (p.c|0))) });
        if (mapStart) mapStart = adj(mapStart);
        if (mapGoal)  mapGoal  = adj(mapGoal);
        checkpoints = Array.isArray(map?.checkpoints) ? map.checkpoints.map(adj) : [];
        items       = Array.isArray(map?.items) ? map.items.map(adj) : [];
        obstacles   = Array.isArray(map?.obstacles) ? map.obstacles.map(adj) : [];

        CANVAS.width  = COLS * t;
        CANVAS.height = ROWS * t;

        // CSS scale canvas to fit the board container without cropping
        const boardEl = document.querySelector('.board');
        // If map json provides viewport hint, honor it for exact match with editor
        if(map && map.viewport && Number.isFinite(map.viewport.cssWidth) && Number.isFinite(map.viewport.cssHeight)){
          boardEl.style.width  = map.viewport.cssWidth + 'px';
          boardEl.style.height = map.viewport.cssHeight + 'px';
          boardEl.style.aspectRatio = `${COLS} / ${ROWS}`;
          CANVAS.style.width  = map.viewport.cssWidth + 'px';
          CANVAS.style.height = map.viewport.cssHeight + 'px';
        } else {
          // Fallback: fit responsively into board
          if(boardEl && COLS && ROWS){ boardEl.style.aspectRatio = `${COLS} / ${ROWS}`; }
          function fitCanvasCSS(){
            const availW = boardEl.clientWidth  || (COLS * t);
            const availH = boardEl.clientHeight || (ROWS * t);
            const sx = availW / (COLS * t);
            const sy = availH / (ROWS * t);
            const s = Math.min(sx, sy); // allow upscale; canvas uses pixelated rendering
            CANVAS.style.width  = Math.floor(CANVAS.width  * s) + 'px';
            CANVAS.style.height = Math.floor(CANVAS.height * s) + 'px';
          }
          fitCanvasCSS();
          new ResizeObserver(fitCanvasCSS).observe(boardEl);
        }

        await TerrainEngine.init({
          atlasUrl: ATLAS_JSON,
          layersUrl: LAYERS_JSON,
          variant: (map && map.variant) || atlasJson.defaultVariant || 'color1',
          canvas: CANVAS
        });

        tileSize = t;
        // Expose meta for overlay module (goal pointer etc.)
        try {
          window.__gvp4_meta = { tileSize: t, cols: COLS, rows: ROWS, goal: { ...goal } };
          window.dispatchEvent(new CustomEvent('gvp4:meta', { detail: window.__gvp4_meta }));
        } catch(_){ }

        // Optional: tiled water background texture
        try{ await TerrainEngine.setWaterTexture('/elearn/models/ts-fp/Terrain/Water%20Background%20color.png'); }catch(_){ }
        try{ await TerrainEngine.enableWaterWaves({ fps: 12, opacity: 0.7 }); }catch(_){ }

        // Build grids either from map json or fallback to a handcrafted island
        const g  = TerrainEngine.getGrid('ground');
        const w  = TerrainEngine.getGrid('water');
        const cl = TerrainEngine.getGrid('cliff_land');
        const cl2= TerrainEngine.getGrid('cliff_land2');
        const cw = TerrainEngine.getGrid('cliff_water');
        const sl = TerrainEngine.getGrid('slopes');

        function applyMask(grid, mask){
          if(!grid || !mask) return;
          for(let r=0;r<ROWS;r++){
            for(let c=0;c<COLS;c++){
              const bit = mask[r]?.charAt(c) === '1' ? 1 : 0;
              grid[r][c] = bit;
            }
          }
        }
        function applyColors(grid, colors){
          if(!grid || !colors) return;
          for(let r=0;r<ROWS;r++){
            const row = colors[r] || ''.padEnd(COLS,'0');
            for(let c=0;c<COLS;c++){
              const ch = row.charAt(c);
              const n = parseInt(ch,10);
              grid[r][c] = Number.isFinite(n) ? n : (ch==='1'?1:0);
            }
          }
        }

        if(map && map.layers){
          applyMask(w,  map.layers.water);
          // If map.colors exists, prefer exact per-cell palette codes
          if(map.colors){
            applyColors(g,  map.colors.ground);
            applyColors(cl, map.colors.cliff_land);
            applyColors(cw, map.colors.cliff_water);
            applyColors(cl2, map.colors.cliff_land2);
            applyColors(sl, map.colors.slopes);
          } else {
            applyMask(g,  map.layers.ground);
            applyMask(cl, map.layers.cliff_land);
            applyMask(cw, map.layers.cliff_water);
            applyMask(cl2, map.layers.cliff_land2);
            applyMask(sl, map.layers.slopes);
          }
          if(g)  TerrainEngine.setGrid('ground', g);
          if(w)  TerrainEngine.setGrid('water', w);
          if(cl) TerrainEngine.setGrid('cliff_land', cl);
          if(cl2)TerrainEngine.setGrid('cliff_land2', cl2);
          if(cw) TerrainEngine.setGrid('cliff_water', cw);
          if(sl) TerrainEngine.setGrid('slopes', sl);
          try{ TerrainEngine.render(); }catch(_){}
          // Expose map to module overlay and fire event for decor/buildings rendering
          try{ window.__gvp4_map = map; window.dispatchEvent(new CustomEvent('gvp4:mapLoaded', { detail:{ map } })); }catch(_){ }
        } else {
          // --- Fallback handcrafted layout (8x8) with plateau, stairs, and small islets ---
          const G = [
            '01111000',
            '01111100',
            '11111100',
            '11101110',
            '11101110',
            '01111110',
            '00111100',
            '00010000'
          ];
          const CL = [
            '00111000',
            '00111000',
            '00000000',
            '00001000',
            '00000000',
            '00000000',
            '00000000',
            '00000000'
          ];
          const CW = [
            '00000000',
            '00000000',
            '00000000',
            '00000010',
            '00000000',
            '00000000',
            '00000110',
            '00000000'
          ];
          const SL = [
            '00000000',
            '00000000',
            '00000000',
            '00001000',
            '00000000',
            '00000100',
            '00000000',
            '00000000'
          ];
          // Fill water everywhere then carve ground/cliffs
          for(let r=0;r<ROWS;r++){ for(let c=0;c<COLS;c++){ if(w&&w[r]) w[r][c]=1; if(g&&g[r]) g[r][c]=0; if(cl&&cl[r]) cl[r][c]=0; if(cw&&cw[r]) cw[r][c]=0; if(sl&&sl[r]) sl[r][c]=0; } }
          applyMask(g, G); applyMask(cl, CL); applyMask(cw, CW); applyMask(sl, SL);
          if(g)  TerrainEngine.setGrid('ground', g);
          if(w)  TerrainEngine.setGrid('water', w);
          if(cl) TerrainEngine.setGrid('cliff_land', cl);
          if(cl2)TerrainEngine.setGrid('cliff_land2', cl2);
          if(cw) TerrainEngine.setGrid('cliff_water', cw);
          if(sl) TerrainEngine.setGrid('slopes', sl);
          try{ TerrainEngine.render(); }catch(_){}
        }

        // Render + posisikan robot
        TerrainEngine.render();
        // Ensure consumers can access current tileSize
        try{ window.__gvp4_tileSize = t; }catch(_){ }
        placeRobot();
      } catch (e){
        console.error('[GameVP4] setupTerrainMini error:', e);
        drawFallback();
      }
    })();
  }
  // Compute simple per-slide start/goal presets based on grid size
  function levelPreset(n, R, C){
    // Keep player near right, goal near left; vary rows each slide
    const rows = Math.max(4, R);
    const cols = Math.max(4, C);
    const bandTop = 2, bandBottom = rows - 3;
    const span = Math.max(1, bandBottom - bandTop);
    const r = bandTop + ((n-1) % span);
    const start = { r, c: Math.max(1, cols - 2) };
    const goal  = { r, c: 1 };
    return { start, goal };
  }
  // Poll sampai ready (maks 2 detik)
  (function waitForTerrain(maxTry=20){
    if(window.TerrainAtlas && window.TerrainEngine){ setupTerrainMini(); return; }
    if(maxTry<=0){ setupTerrainMini(); return; } // akan gambar fallback + warning
    setTimeout(()=>waitForTerrain(maxTry-1), 100);
  })();

  // Walkability: check ground, water, cliff_land using TerrainEngine layers
  function isWalkable(r, c, fromDir) {
    // Saat engine belum siap (fallback) â†’ izinkan selama masih di papan
    if (!(window.TerrainEngine && TerrainEngine.getGrid)) {
      return r>=0 && c>=0 && r<ROWS && c<COLS;
    }
    if (r < 0 || c < 0 || r >= ROWS || c >= COLS) return false;

    const g  = TerrainEngine.getGrid('ground');
    const w  = TerrainEngine.getGrid('water');
    const cl = TerrainEngine.getGrid('cliff_land');
    const cl2= TerrainEngine.getGrid('cliff_land2');
    const cw = TerrainEngine.getGrid('cliff_water');
    const sl = TerrainEngine.getGrid('slopes');

    const val = (grid, rr, cc) => (grid && grid[rr] ? (grid[rr][cc] ? 1 : 0) : 0);
    const levelAt = (rr, cc) => {
      const base = val(g, rr, cc) ? 1 : (val(cw, rr, cc) ? 1 : 0);
      return base + val(cl, rr, cc) + val(cl2, rr, cc);
    };
    const hereLvl = levelAt(pos.r, pos.c);
    const thereLvl = levelAt(r, c);
    if (thereLvl <= 0) return false; // water/void
    const delta = thereLvl - hereLvl;
    if (Math.abs(delta) === 0) return true;
    if (Math.abs(delta) > 1) return false; // too steep
    // Require slopes at source or target cell to change elevation
    const slopeHere = val(sl, pos.r, pos.c) === 1;
    const slopeThere = val(sl, r, c) === 1;
    return slopeHere || slopeThere;
  }

  // --- Robot state ---
  // DOM robot removed; keep logical position only and notify overlay
  let dir = 0; // 0:right, 1:down, 2:left, 3:up
  let pos = {r:start.r, c:start.c};

  // Visual-only correction so warrior aligns 1:1 with Map Editor markers.
  // If you observe a 1-row shift, tweak this to 0 or -1 accordingly.
  const OVERLAY_ROW_OFFSET = +1; // -1 moves warrior up one row; 0 = no shift
  function placeRobot(){
    // Use actual CSS-scaled tile size so DOM placement matches canvas
    const baseTile = (typeof tileSize === 'number') ? tileSize : 64;
    const canvasBB = CANVAS.getBoundingClientRect();
    const boardBB  = CANVAS.parentElement.getBoundingClientRect();
    const scaleX = CANVAS.width > 0 ? (canvasBB.width / CANVAS.width) : 1;
    const tcss = baseTile * scaleX;
    const x = (canvasBB.left - boardBB.left) + pos.c * tcss + tcss/2 - 26;
    const y = (canvasBB.top  - boardBB.top)  + pos.r * tcss + tcss/2 - 26;
    // Notify overlay listeners to sync warrior position using canvas tile size (not CSS)
    const centerX = (canvasBB.left - boardBB.left) + pos.c * tcss + tcss/2;
    const centerY = (canvasBB.top  - boardBB.top)  + pos.r * tcss + tcss/2;
    const canvasTile = (typeof tileSize === 'number' && tileSize > 0) ? tileSize : (CANVAS.width/Math.max(1,COLS));
    const rOverlay = Math.max(0, Math.min(ROWS-1, pos.r + OVERLAY_ROW_OFFSET));
    window.dispatchEvent(new CustomEvent('gvp4:place', { detail:{ r:rOverlay, c:pos.c, dir, tileSize: canvasTile, x:centerX, y:centerY } }));
  }
  // Allow external listeners to request current placement broadcast
  window.addEventListener('gvp4:requestPlace', ()=>{ placeRobot(); });
  window.addEventListener('resize', placeRobot);
  setTimeout(placeRobot, 0);

  // --- Blocks drag & program ---
  const palette = document.getElementById('palette');
  const workspace = document.getElementById('workspace');
  const stack = document.getElementById('stack');
  const blockCount = document.getElementById('blockCount');
  const toast = document.getElementById('toast');
  const trash = document.getElementById('trash');

  // Step-by-step state
  let blocksCache = [];
  let pc = 0;            // program counter
  let hasStarted = false; // whether stepping has begun
  let draggingEl = null; // current block dragged from stack

  // === Blockly integration ===
  // Define Clay Theme (pastel colors and readable toolbox)
  const ClayTheme = Blockly.Theme.defineTheme('clay', {
    'base': Blockly.Themes.Classic,
    'blockStyles': {
      'robot_blocks': {
        'colourPrimary': '#8b9bff',
        'colourSecondary': '#6b7ae6',
        'colourTertiary': '#4d5cc7'
      },
      'control_blocks': {
        'colourPrimary': '#ffb86b',
        'colourSecondary': '#e89b4a',
        'colourTertiary': '#cc7f2f'
      }
    },
    'categoryStyles': {
      'robot_category': {'colour': '#8b9bff'},
      'control_category': {'colour': '#ffb86b'}
    },
    'componentStyles': {
      'workspaceBackgroundColour': '#eef2f6',
      'toolboxBackgroundColour': '#f3f6fb',
      'toolboxForegroundColour': '#111827',
      'flyoutBackgroundColour': '#f8fafc',
      'flyoutForegroundColour': '#334155',
      'flyoutOpacity': 1,
      'scrollbarColour': '#cbd5e1',
      'insertionMarkerColour': '#94a3b8',
      'insertionMarkerOpacity': 0.6
    }
  });
  let ws; // Blockly workspace

  // Minimal toolbox for robot
  const toolbox = {
    "kind":"categoryToolbox",
    "contents":[
      {"kind":"category","name":"Gerak","categorystyle":"robot_category","contents":[
        {"kind":"block","type":"robot_move"},
        {"kind":"block","type":"robot_turn"}
      ]},
      {"kind":"category","name":"Kontrol","categorystyle":"control_category","contents":[
        {"kind":"block","type":"robot_repeat"}
      ]}
    ]
  };

  // Define custom robot blocks
  Blockly.defineBlocksWithJsonArray([
    {"type":"robot_move","message0":"melangkah maju","previousStatement":null,"nextStatement":null,"style":"robot_blocks"},
    {"type":"robot_turn","message0":"belok %1","args0":[{"type":"field_dropdown","name":"DIR","options":[["kiri â†º","LEFT"],["kanan â†»","RIGHT"]]}],"previousStatement":null,"nextStatement":null,"style":"robot_blocks"},
    {"type":"robot_repeat","message0":"ulangi %1 kali %2",
      "args0":[{"type":"field_number","name":"TIMES","value":2,"min":1,"max":20},{"type":"input_statement","name":"DO"}],
      "previousStatement":null,"nextStatement":null,"style":"control_blocks"}
  ]);

  function initBlockly(){
    const host = document.getElementById('blocklyDiv');
    if(!host || typeof Blockly==='undefined') return;
    ws = Blockly.inject(host, {
      toolbox,
      theme: ClayTheme,
      trashcan: true,
      scrollbars: true,
      zoom: {controls:true, wheel:true, startScale:1, maxScale:2, minScale:.5}
    });
    window.addEventListener('resize', ()=>Blockly.svgResize(ws));
    setTimeout(()=>Blockly.svgResize(ws),0);
  }

  // Convert Blockly chains â†’ array of robot commands (strings)
  function programFromBlockly(){
    const out = [];
    if(!ws) return out;
    const tops = ws.getTopBlocks(true);
    for(const t of tops){ collect(t, out); }
    return out;

    function collect(block, arr){
      if(!block) return;
      switch(block.type){
        case 'robot_move': arr.push('move'); break;
        case 'robot_turn': {
          const d = (block.getFieldValue('DIR')||'LEFT');
          arr.push(d === 'LEFT' ? 'left' : 'right');
          break;
        }
        case 'robot_repeat': {
          const n = parseInt(block.getFieldValue('TIMES')||1,10);
          const inner = block.getInputTargetBlock('DO');
          for(let i=0;i<n;i++) collect(inner, arr);
          break;
        }
      }
      const next = block.getNextBlock();
      if(next) collect(next, arr);
    }
  }

  function loadProgram(){
    blocksCache = programFromBlockly();
  }

  function showToast(msg, type){
    toast.textContent = msg;
    toast.className = 'toast show' + (type? ' ' + type : '');
    setTimeout(()=>toast.className='toast', 1600);
  }

  function updateCounter(){
    const used = stack.querySelectorAll('.block').length;
    blockCount.textContent = used;
    stack.querySelector('.placeholder')?.remove();
    if(used===0){
      const ph = document.createElement('div');
      ph.className='placeholder'; ph.textContent='Taruh blok di siniâ€¦';
      stack.appendChild(ph);
    }
    // refresh program + reset step state on any change
    loadProgram();
    pc = 0;
    hasStarted = false;
  }

  // Make palette blocks clonable on drag
  palette.addEventListener('dragstart', e=>{
    const b = e.target.closest('.block');
    if(!b) return;
    e.dataTransfer.setData('text/plain', b.dataset.type);
    b.classList.add('dragging');
  });
  palette.addEventListener('dragend', e=>{
    e.target.classList.remove('dragging');
  });

  stack.addEventListener('dragover', e=>{ e.preventDefault(); });
  stack.addEventListener('drop', e=>{
    e.preventDefault();
    const type = e.dataTransfer.getData('text/plain');
    if(!type) return;
    const nb = document.createElement('div');
    nb.className = 'block';
    nb.draggable = true;
    nb.dataset.type = type;
    nb.textContent = type==='move' ? 'melangkah maju' : (type==='left' ? 'Belok kiri â†º' : 'Belok kanan â†»');
    stack.appendChild(nb);
    updateCounter();
  });

  // Allow re-order & deletion (double click)
  stack.addEventListener('dragstart', e=>{
    const b = e.target.closest('.block');
    if(!b) return; e.dataTransfer.setData('text/plain', 'reorder');
    e.dataTransfer.setDragImage(b, 20, 20);
    b.classList.add('dragging');
    draggingEl = b;
  });
  stack.addEventListener('dragend', e=>{ e.target.classList.remove('dragging'); draggingEl = null; updateCounter(); });
  // Trash dropzone (optional): only if element exists
  if(trash){
    ['dragenter','dragover'].forEach(ev=> trash.addEventListener(ev, e=>{ e.preventDefault(); trash.classList.add('active'); }));
    ['dragleave','drop'].forEach(ev=> trash.addEventListener(ev, e=>{ trash.classList.remove('active'); }));
    trash.addEventListener('drop', e=>{
      e.preventDefault();
      const kind = e.dataTransfer.getData('text/plain');
      if(kind === 'reorder' && draggingEl){ draggingEl.remove(); updateCounter(); showToast('Blok dihapus.'); }
    });
  }
  stack.addEventListener('dragover', e=>{
    const dragging = stack.querySelector('.block.dragging');
    if(!dragging) return;
    const after = Array.from(stack.querySelectorAll('.block:not(.dragging)'))
      .find(el => e.clientX <= el.getBoundingClientRect().left + el.offsetWidth/2);
    if(after) stack.insertBefore(dragging, after); else stack.appendChild(dragging);
  });
  stack.addEventListener('dblclick', e=>{
    const b = e.target.closest('.block');
    if(!b) return; b.remove(); updateCounter();
  });

  // Controls
  document.getElementById('btnClear').onclick = ()=>{ stack.innerHTML = ''; updateCounter(); };

  document.getElementById('btnStep').onclick = ()=>{ stepOnce(); };
  document.getElementById('btnReset').onclick = ()=>{ pc = 0; hasStarted = false; pos = {r:start.r, c:start.c}; dir = 0; placeRobot(); showToast('Diulang dari awal.'); };
  document.getElementById('btnRun').onclick = ()=>{ runProgram(); };
  const btnPlaySide = document.getElementById('btnPlaySide');
  if(btnPlaySide){ btnPlaySide.onclick = ()=>{ runProgram(); }; }

  // Program runner
  let running = false;
  async function runProgram(){
    if(running) return; running = true;
    // start from beginning for full run
    loadProgram();
    pos = {r:start.r, c:start.c}; dir = 0; placeRobot();
    pc = 0; hasStarted = true;
    if(blocksCache.length===0){ showToast('Tambahkan blok dulu, ya!', 'fail'); running=false; return; }

    for(let i=0;i<blocksCache.length;i++){
      const t = blocksCache[i];
      const ok = await exec(t);
      if(!ok){ showToast('Ups, menabrak dinding.', 'fail'); break; }
      pc++;
      if(pos.r===goal.r && pos.c===goal.c){
        const need = (checkpoints.length>0 || items.length>0);
        const ok = (!need) || (visited.size>=checkpoints.length && collected.size>=items.length);
        if(ok){ showToast('Mantap! Sampai tujuan âœ”', 'success'); try{ onWinOnce(); }catch(_){} break; }
        else { showToast('Belum memenuhi syarat!'); }
      }
    }
    running = false;
  }

  async function stepOnce(){
    if(running) return;
    // ensure we have latest program cache
    if(blocksCache.length===0){ loadProgram(); }
    if(blocksCache.length===0){ showToast('Tambahkan blok dulu, ya!', 'fail'); return; }

    if(!hasStarted){ // first step: reset to start
      pos = {r:start.r, c:start.c}; dir = 0; placeRobot();
      hasStarted = true; pc = 0;
    }
    if(pc >= blocksCache.length){ showToast('Program selesai. Klik Reset untuk ulang.', 'fail'); return; }

    running = true;
    const ok = await exec(blocksCache[pc]);
    running = false;
    if(!ok){ showToast('Ups, menabrak dinding.', 'fail'); return; }

    pc++;
    if(pos.r===goal.r && pos.c===goal.c){
      const need = (checkpoints.length>0 || items.length>0);
      const ok = (!need) || (visited.size>=checkpoints.length && collected.size>=items.length);
      if(ok){ showToast('Mantap! Sampai tujuan âœ”', 'success'); try{ onWinOnce(); }catch(_){} }
      else { showToast('Belum memenuhi syarat!'); }
    }
  }

  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
  async function exec(type){
    if(type==='left'){ dir = (dir+3)%4; placeRobot(); await sleep(220); return true; }
    if(type==='right'){ dir = (dir+1)%4; placeRobot(); await sleep(220); return true; }
    if(type==='move'){
      const next = {
        r: pos.r + (dir===1?1:dir===3?-1:0),
        c: pos.c + (dir===0?1:dir===2?-1:0)
      };

      // Cek batas atlas
      if(next.r<0 || next.c<0 || next.r>=ROWS || next.c>=COLS){
        await sleep(220); return false;
      }

      // Cek walkability berdasarkan jenis tile (ground/water/cliff/slope)
      if(!isWalkable(next.r, next.c, dir)){
        await sleep(220); return false;
      }

      // Announce start of movement for overlay animation (run)
      window.dispatchEvent(new CustomEvent('gvp4:moveStart', { detail:{ from:{...pos}, to:next, dir } }));
      pos = next; placeRobot();
      // Gameplay markers
      const key = `${pos.r},${pos.c}`;
      // Obstacle -> reset to start
      if(obstacles.some(p=>p.r===pos.r && p.c===pos.c)){
        showToast('Menabrak rintangan! Kembali ke Start.', 'fail');
        pos = {r:start.r, c:start.c}; dir = 0; placeRobot();
        await sleep(260);
        window.dispatchEvent(new CustomEvent('gvp4:moveEnd', { detail:{ pos:{...pos}, dir } }));
        return false;
      }
      if(checkpoints.some(p=>p.r===pos.r && p.c===pos.c)) visited.add(key);
      if(items.some(p=>p.r===pos.r && p.c===pos.c)) collected.add(key);
      await sleep(260);
      window.dispatchEvent(new CustomEvent('gvp4:moveEnd', { detail:{ pos:{...pos}, dir } }));
      return true;
    }
    return true;
  }

  // Slide navigation: highlight current + allow click to jump
  (function initSlides(){
    const dots = Array.from(document.querySelectorAll('.top-slides .slide-dot'));
    dots.forEach((el,i)=>{
      const idx=i+1; el.classList.toggle('inactive', idx!==curSlide);
      el.onclick = ()=>{
        const sp = new URLSearchParams(location.search); sp.set('s', String(idx));
        location.search = sp.toString();
      };
    });
  })();
  initBlockly();
  updateCounter();
})();
</script>

<script>
// Simple win popup + coin claim integration
(function(){
  let WIN_DONE = false;
  window.onWinOnce = async function(){
    if (WIN_DONE) return; WIN_DONE = true;
    try{ showWinPopup({ state:'pending' }); }catch(_){ }
    try{
      // Attach slide to lesson id so points can be configured per slide in points.config.json overrides
      const s = new URLSearchParams(location.search).get('s') || '1';
      const payload = { course_id: 'kindercoder', lesson_id: `gamevp4-s${s}` };
      // Try to pass FE user as header (server middleware accepts X-UID/X-ROLE)
      let info = {};
      try { if (typeof getUserInfo === 'function') info = getUserInfo() || {}; } catch(_){}
      const headers = { 'Content-Type': 'application/json' };
      if (info.uid) headers['X-UID'] = String(info.uid);
      if (info.role) headers['X-ROLE'] = String(info.role).toLowerCase();
      const res = await fetch('/api/points/claim', { method:'POST', credentials:'include', headers, body: JSON.stringify(payload) });
      const data = await res.json().catch(()=>({ ok:false }));
      if (data && (data.ok || typeof data.total_points === 'number')){
        const total = Number(data.total_points || 0);
        const added = Number(data.added || 0);
        try { window.dispatchEvent(new CustomEvent('points:updated', { detail:{ total_points: total } })); } catch(_){ }
        showWinPopup({ state:'success', added, total });
      } else {
        showWinPopup({ state:'error', message: (data && (data.error||data.message)) || 'Gagal klaim poin' });
      }
    } catch (e) {
      showWinPopup({ state:'error', message: e.message || 'Gagal klaim poin' });
    }
  };

  function showWinPopup({ state='success', added=0, total=0, message='' }={}){
    // Reuse if already visible
    let ov = document.getElementById('gvpWinOverlay');
    if (!ov) {
      ov = document.createElement('div'); ov.id='gvpWinOverlay';
      Object.assign(ov.style,{ position:'fixed', inset:'0', background:'rgba(0,0,0,0.6)', display:'flex', alignItems:'center', justifyContent:'center', zIndex:10060 });
      const box = document.createElement('div'); box.id='gvpWinBox';
      Object.assign(box.style,{ width:'min(560px,92vw)', background:'#111827', color:'#fff', border:'1px solid #243249', borderRadius:'14px', boxShadow:'0 10px 30px rgba(0,0,0,.45)', padding:'18px 20px' });
      box.innerHTML = `
        <div style="font-size:28px;font-weight:900;letter-spacing:.5px;text-align:center;margin-bottom:8px">MENANG ðŸŽ‰</div>
        <div id="gvpWinBody" style="text-align:center;font-size:15px;opacity:.95">Sedang memproses hadiah...</div>
        <div style="display:flex;gap:10px;justify-content:center;margin-top:14px">
          <button id="gvpContinue" style="background:#22c55e;color:#0b1220;border:none;border-radius:10px;padding:10px 16px;font-weight:800;cursor:pointer">Lanjutkan</button>
        </div>`;
      ov.appendChild(box);
      document.body.appendChild(ov);
      document.getElementById('gvpContinue').onclick = ()=>{
        // Next slide by query param ?s=..
        const sp = new URLSearchParams(location.search);
        const cur = Math.max(1, Math.min(12, parseInt(sp.get('s')||'1',10)||1));
        const next = Math.min(12, cur + 1);
        sp.set('s', String(next));
        location.search = sp.toString();
      };
      ov.addEventListener('click', (e)=>{ if (e.target===ov) ov.remove(); });
      document.addEventListener('keydown', (e)=>{ if (e.key==='Escape') ov.remove(); }, { once:true });
    }
    const body = document.getElementById('gvpWinBody');
    if (!body) return;
    if (state==='pending'){
      body.textContent = 'Sedang memproses hadiah...';
    } else if (state==='success'){
      body.innerHTML = `
        <div style="display:flex;justify-content:center;gap:14px;align-items:baseline;margin:6px 0 2px">
          <div style="font-size:40px">ðŸª™</div>
          <div style="font-size:40px;font-weight:900">+${added}</div>
        </div>
        <div style="opacity:.9;margin-top:6px">Total Coin: ${total}</div>
      `;
    } else {
      body.innerHTML = `<div style="color:#fecaca">${message || 'Terjadi kesalahan.'}</div>`;
    }
  }
})();
</script>

<script type="module">
  import * as Assets from '/elearn/engine/assets-runtime.js';

  const terrain = document.getElementById('terrainMini');
  const overlay = document.getElementById('overlaySprites');
  function syncOverlaySize(){
    overlay.width = terrain.width; overlay.height = terrain.height;
    overlay.style.width = terrain.style.width; overlay.style.height = terrain.style.height;
  }
  syncOverlaySize(); new ResizeObserver(syncOverlaySize).observe(terrain);

  await Assets.init({ manifestUrl:'/elearn/assets/manifest.json', prewarm:['unit','building','decor'] });

  const scene = Assets.createScene(overlay);
  // Note: Remove sample spawns to avoid fallback red boxes when assets are missing
  // const gob = await Assets.spawn('goblin_scout', { x: 96, y: 96, state:{anim:'idle'} });
  // const castle = await Assets.spawn('castle_blue', { x: 240, y: 180 });
  // const trees = await Assets.spawn('forest_pack_a');
  // scene.add(gob, castle, trees);

  // --- Warrior overlay actor (uses PNG strips, not Aseprite JSON) ---
  const WARRIOR_BASE = '/elearn/models/ts-fp/Units/Blue Units/Warrior';
  const W_STATES = ['Idle','Run','Guard','Attack1','Attack2'];
  const W_FPS = { Idle:6, Run:12, Guard:8, Attack1:12, Attack2:12 };
  function inferMeta(img){
    let frames=1, fw=img.width, fh=img.height, vertical=false;
    if(img.width>img.height && img.width%img.height===0){ frames=img.width/img.height; fw=img.height; fh=img.height; }
    else if(img.height>img.width && img.height%img.width===0){ frames=img.height/img.width; fw=img.width; fh=img.width; vertical=true; }
    else{ for(let n=2;n<=16;n++){ if(img.width % n===0){ frames=n; fw=img.width/n; fh=img.height; break; } } }
    return {frames, fw, fh, vertical};
  }
  function loadImage(src){ return new Promise((res,rej)=>{ const im=new Image(); im.onload=()=>res(im); im.onerror=rej; im.src=src; }); }
  async function loadWarrior(){
    const cache=new Map();
    for(const s of W_STATES){
      try{ const img = await loadImage(`${WARRIOR_BASE}/Warrior_${s}.png`); cache.set(s,{img, ...inferMeta(img)}); }
      catch{ /* tolerate */ }
    }
    return cache;
  }
  const warrior = {
    cache: await loadWarrior(), x: 0, y: 0, state: 'Idle', t: 0, frameIdx:0, acc:0,
    update(dt){ this.t += dt; this.acc += dt; const fps=W_FPS[this.state]||10; const frameMs=1000/fps; const entry=this.cache.get(this.state)||this.cache.get('Idle'); if(!entry) return; while(this.acc>=frameMs){ this.acc-=frameMs; this.frameIdx=(this.frameIdx+1)%(entry.frames||1);} },
    draw(ctx){ const entry=this.cache.get(this.state)||this.cache.get('Idle'); if(!entry) return; const {img,frames,fw,fh,vertical}=entry; const idx=this.frameIdx%(frames||1); const sx=vertical?0:idx*fw; const sy=vertical?idx*fh:0; const scale=1; const dx=Math.round(this.x - fw*scale/2); const dy=Math.round(this.y - fh*scale); ctx.drawImage(img, sx, sy, fw, fh, dx, dy, fw*scale, fh*scale); }
  };
  // Do not add warrior directly; we will draw it within decor pass for proper y-sorting

  // Sync warrior with robot grid position via custom events from the non-module script
  window.addEventListener('gvp4:place', (e)=>{
    // e.detail contains center x,y computed in DOM space; we need canvas coords (overlay origin is the board's center canvas origin)
    // Because overlay is absolutely centered over terrain canvas and has identical pixel size, we can compute x,y based on tileSize and pos.
    const { r, c, tileSize } = e.detail || {};
    warrior.x = c * tileSize + tileSize/2;
    warrior.y = r * tileSize + tileSize/2;
  });
  window.addEventListener('gvp4:moveStart', ()=>{ warrior.state = 'Run'; warrior.acc=0; });
  window.addEventListener('gvp4:moveEnd',   ()=>{ warrior.state = 'Idle'; });

  // Robot SVG removed; warrior overlay is the only character

  // Ask for initial placement once listeners are ready
  window.dispatchEvent(new CustomEvent('gvp4:requestPlace'));

  scene.start();

  // --- Map Decor/Building/Torch renderer (reads JSON exported by map-editor) ---
  // Minimal loaders copied from editor, adapted for viewer-only (no interactions)
  const TREE_BASE = "/elearn/models/ts-fp/Decorations/Trees/";
  const TREE_SHEETS = {1: TREE_BASE+"Tree1.png", 2: TREE_BASE+"Tree2.png", 3: TREE_BASE+"Tree3.png", 4: TREE_BASE+"Tree4.png"};
  const TREE_JSON = TREE_BASE + "Trees.json";
  const SHEEP_BASE = "/elearn/models/ts-fp/Decorations/Sheep/";
  const SHEEP_SHEETS = { idle: SHEEP_BASE+"Sheep_Idle.png", grass: SHEEP_BASE+"Sheep_Grass.png", move: SHEEP_BASE+"Sheep_Move.png" };
  const SHEEP_JSON = SHEEP_BASE + "Sheep.json";
  const TORCH_BASE = "/elearn/models/ts-up/Factions/Goblins/Troops/Torch/Purple/";
  const TORCH_SHEET = TORCH_BASE + "Torch_Purple.png";
  const TORCH_JSON = TORCH_BASE + "Torch_Purple.json";

  const treeImgCache = new Map();
  const treeFramesCache = new Map();
  const sheepImgCache = new Map();
  const sheepFramesCache = new Map();
  let torchImg = null; const torchFramesCache = new Map();

  function loadImg2(src){ return new Promise((res,rej)=>{ const im=new Image(); im.onload=()=>res(im); im.onerror=()=>rej(new Error('img:'+src)); im.src=src; }); }
  async function loadTreeImg(idx){ if(!treeImgCache.has(idx)) treeImgCache.set(idx, await loadImg2(TREE_SHEETS[idx])); return treeImgCache.get(idx); }
  async function loadTreeFrames(idx){
    if(treeFramesCache.has(idx)) return treeFramesCache.get(idx);
    let doc=null; try{ const r=await fetch(TREE_JSON, {cache:'no-cache'}); if(r.ok) doc=await r.json(); }catch(_){ }
    let frames=[]; if(doc){ const framesArray = Object.values(doc.frames||{}); const tag=(doc.meta?.frameTags||[]).find(t=> (t.name||'').toLowerCase()===('tree '+idx)); if(tag){ const baseX=framesArray[tag.from].frame.x; for(let i=tag.from;i<=tag.to;i++){ const f=framesArray[i]; frames.push({sx:f.frame.x-baseX, sy:f.frame.y, w:f.frame.w, h:f.frame.h, dur:f.duration}); } } }
    if(frames.length===0){ const w=192,h=256; for(let i=0;i<8;i++) frames.push({sx:i*w, sy:0, w, h, dur:100}); }
    treeFramesCache.set(idx, frames); return frames;
  }
  async function loadSheepImg(anim){ const key=(anim||'idle').toLowerCase(); if(!sheepImgCache.has(key)) sheepImgCache.set(key, await loadImg2(SHEEP_SHEETS[key])); return sheepImgCache.get(key); }
  async function loadSheepFrames(anim){
    const key=(anim||'idle').toLowerCase(); if(sheepFramesCache.has(key)) return sheepFramesCache.get(key);
    let doc=null; try{ const r=await fetch(SHEEP_JSON, {cache:'no-cache'}); if(r.ok) doc=await r.json(); }catch(_){ }
    let frames=[]; if(doc && doc.frames){ const framesArray=Object.values(doc.frames); const tag=(doc.meta?.frameTags||[]).find(t=> (t.name||'').toLowerCase()===key); if(tag){ const baseX=framesArray[tag.from].frame.x; for(let i=tag.from;i<=tag.to;i++){ const f=framesArray[i]; frames.push({ sx:f.frame.x-baseX, sy:f.frame.y, w:f.frame.w, h:f.frame.h, dur:f.duration }); } } }
    if(frames.length===0){ for(let i=0;i<8;i++) frames.push({ sx:i*128, sy:0, w:128, h:128, dur:100 }); }
    sheepFramesCache.set(key, frames); return frames;
  }
  async function loadTorchImg(){ if(!torchImg) torchImg = await loadImg2(TORCH_SHEET); return torchImg; }
  async function loadTorchFrames(anim){
    const key=(anim||'idle').toLowerCase(); if(torchFramesCache.has(key)) return torchFramesCache.get(key);
    let doc=null; try{ const r=await fetch(TORCH_JSON, {cache:'no-cache'}); if(r.ok) doc=await r.json(); }catch(_){ }
    let rawFrames=[]; if(doc && doc.frames){ const framesArray=Object.values(doc.frames); const tag=(doc.meta?.frameTags||[]).find(t => (t.name||'').toLowerCase()===key); if(tag){ for(let i=tag.from;i<=tag.to;i++){ const f=framesArray[i]; if(f?.frame?.w>0 && f?.frame?.h>0){ rawFrames.push({ sx:f.frame.x, sy:f.frame.y, w:f.frame.w, h:f.frame.h, dur:f.duration||100 }); } } } }
    if(rawFrames.length===0){ const w=192,h=192; const guess=[]; for(let i=0;i<3;i++) guess.push({sx:i*w, sy:0, w, h, dur:100}); torchFramesCache.set(key, guess); return guess; }
    await loadTorchImg();
    const off=document.createElement('canvas'); off.width=Math.max(...rawFrames.map(f=>f.w))||1; off.height=Math.max(...rawFrames.map(f=>f.h))||1; const octx=off.getContext('2d',{willReadFrequently:true});
    const filtered=[]; for(const f of rawFrames){ octx.clearRect(0,0,off.width,off.height); octx.drawImage(torchImg, f.sx, f.sy, f.w, f.h, 0, 0, f.w, f.h); const imgd=octx.getImageData(0,0,f.w,f.h); let alphaSum=0; const data=imgd.data; for(let i=3;i<data.length;i+=4) alphaSum += data[i]; if(alphaSum>0) filtered.push(f); }
    const frames=filtered.length>0?filtered:rawFrames; torchFramesCache.set(key, frames); return frames;
  }

  function knightBuildingPath(type, color, state){
    const base = '/elearn/models/ts-up/Factions/Knights/Buildings/';
    if(type==='castle'){
      if(state==='construction') return base+'Castle/Castle_Construction.png';
      if(state==='destroyed')    return base+'Castle/Castle_Destroyed.png';
      const col=(color||'blue'); return base+`Castle/Castle_${col[0].toUpperCase()+col.slice(1)}.png`;
    }
    if(type==='tower'){
      if(state==='construction') return base+'Tower/Tower_Construction.png';
      if(state==='destroyed')    return base+'Tower/Tower_Destroyed.png';
      const col=(color||'blue'); return base+`Tower/Tower_${col[0].toUpperCase()+col.slice(1)}.png`;
    }
    const colMap = {house1:'blue', house2:'red', house3:'yellow'};
    const houseCol = colMap[type] || 'blue';
    if(state==='construction') return base+'House/House_Construction.png';
    if(state==='destroyed')    return base+'House/House_Destroyed.png';
    return base+`House/House_${houseCol[0].toUpperCase()+houseCol.slice(1)}.png`;
  }
  function goblinBuildingPath(type, color, state){
    const base = '/elearn/models/ts-up/Factions/Goblins/Buildings/';
    if(type==='wood_tower'){
      if(state==='construction') return base+'Wood_Tower/Wood_Tower_InConstruction.png';
      if(state==='destroyed')    return base+'Wood_Tower/Wood_Tower_Destroyed.png';
      const col=(color||'purple'); const cap=col[0].toUpperCase()+col.slice(1);
      return base+`Wood_Tower/Wood_Tower_${cap}.png`;
    }
    if(type==='wood_house'){
      if(state==='destroyed') return base+'Wood_House/Goblin_House_Destroyed.png';
      return base+'Wood_House/Goblin_House.png';
    }
    return null;
  }

  const decorRuntime = {
    trees:[], sheeps:[], torches:[], buildings:[],
    async fromMap(doc){
      this.trees.length=0; this.sheeps.length=0; this.torches.length=0; this.buildings.length=0;
      for(const t of (doc.decorTrees||[])){ const idx=t.type||1; await loadTreeImg(idx); await loadTreeFrames(idx); this.trees.push({ idx, x:t.x||0, y:t.y||0, scale:t.scale||1, fi:0, acc:0, fps:10 }); }
      for(const s of (doc.decorSheep||[])){ const anim=(s.anim||'idle').toLowerCase(); await loadSheepImg(anim); await loadSheepFrames(anim); this.sheeps.push({ anim, x:s.x||0, y:s.y||0, scale:s.scale||1, fi:0, acc:0, fps:10 }); }
      for(const tt of (doc.goblinTorches||doc.decorTorches||[])){ const anim=(tt.anim||'idle').toLowerCase(); await loadTorchImg(); await loadTorchFrames(anim); this.torches.push({ anim, x:tt.x||0, y:tt.y||0, scale:tt.scale||1, fi:0, acc:0, fps:10 }); }
      for(const b of (doc.buildings||[])){
        const spec={ faction:b.faction||'knight', type:b.type||'castle', color:b.color||'blue', state:b.state||'normal' };
        const src = spec.faction==='knight' ? knightBuildingPath(spec.type, spec.color, spec.state) : goblinBuildingPath(spec.type, spec.color, spec.state);
        if(src){ try{ const img = await loadImg2(src); this.buildings.push({ ...spec, x:b.x||0, y:b.y||0, scale:b.scale||1, img }); }catch(_){} }
      }
    },
    update(dt){
      const adv=(arr)=>{ for(const it of arr){ it.acc += dt; const frameMs=1000/(it.fps||10); while(it.acc>=frameMs){ it.acc-=frameMs; it.fi=(it.fi+1)%8; } } };
      adv(this.trees); adv(this.sheeps); adv(this.torches);
    },
    draw(ctx){
      const list=[];
      for(const t of this.trees){ const fr=(treeFramesCache.get(t.idx)||[])[t.fi]||(treeFramesCache.get(t.idx)||[])[0]; const img=treeImgCache.get(t.idx); if(!fr||!img) continue; const dw=fr.w*t.scale, dh=fr.h*t.scale; const dx=Math.round(t.x-0.5*dw), dy=Math.round(t.y-dh); list.push({y:t.y, draw:()=>ctx.drawImage(img, fr.sx, fr.sy, fr.w, fr.h, dx, dy, dw, dh)}); }
      for(const s of this.sheeps){ const fr=(sheepFramesCache.get((s.anim||'idle'))||[])[s.fi]||(sheepFramesCache.get((s.anim||'idle'))||[])[0]; const img=sheepImgCache.get((s.anim||'idle')); if(!fr||!img) continue; const dw=fr.w*s.scale, dh=fr.h*s.scale; const dx=Math.round(s.x-0.5*dw), dy=Math.round(s.y-dh); list.push({y:s.y, draw:()=>ctx.drawImage(img, fr.sx, fr.sy, fr.w, fr.h, dx, dy, dw, dh)}); }
      for(const t of this.torches){ const fr=(torchFramesCache.get((t.anim||'idle'))||[])[t.fi]||(torchFramesCache.get((t.anim||'idle'))||[])[0]; if(!fr||!torchImg) continue; const dw=fr.w*t.scale, dh=fr.h*t.scale; const dx=Math.round(t.x-0.5*dw), dy=Math.round(t.y-dh); list.push({y:t.y, draw:()=>ctx.drawImage(torchImg, fr.sx, fr.sy, fr.w, fr.h, dx, dy, dw, dh)}); }
      for(const b of this.buildings){ const img=b.img; if(!img) continue; const dw=img.width*(b.scale||1), dh=img.height*(b.scale||1); const dx=Math.round(b.x-0.5*dw), dy=Math.round(b.y-dh); list.push({y:b.y, draw:()=>ctx.drawImage(img, dx, dy, dw, dh)}); }
      list.sort((a,b)=>a.y-b.y); for(const it of list) it.draw();
    }
  };

  const overlayCtx = scene.ctx; // alias
  // Create a scene object to render decor each frame
  let goalMeta = window.__gvp4_meta || null;
  let goalImg = null; let goalPulse = 0; (async()=>{ try{ goalImg = await loadImg2('/elearn/models/ts-up/UI/Pointers/02.png'); }catch(_){} })();
  window.addEventListener('gvp4:meta', (e)=>{ goalMeta = (e && e.detail) || window.__gvp4_meta || null; });

  const decorObj = { 
    update:(dt)=>{ warrior.update(dt); decorRuntime.update(dt); goalPulse += dt; },
    draw:(ctx)=>{
      try{
        // unified y-sorted draw: decor + warrior
        const list=[];
        for(const t of decorRuntime.trees){ const fr=(treeFramesCache.get(t.idx)||[])[t.fi]||(treeFramesCache.get(t.idx)||[])[0]; const img=treeImgCache.get(t.idx); if(!fr||!img) continue; const dw=fr.w*t.scale, dh=fr.h*t.scale; const dx=Math.round(t.x-0.5*dw), dy=Math.round(t.y-dh); list.push({y:t.y, draw:()=>ctx.drawImage(img, fr.sx, fr.sy, fr.w, fr.h, dx, dy, dw, dh)}); }
        for(const s of decorRuntime.sheeps){ const fr=(sheepFramesCache.get((s.anim||'idle'))||[])[s.fi]||(sheepFramesCache.get((s.anim||'idle'))||[])[0]; const img=sheepImgCache.get((s.anim||'idle')); if(!fr||!img) continue; const dw=fr.w*s.scale, dh=fr.h*s.scale; const dx=Math.round(s.x-0.5*dw), dy=Math.round(s.y-dh); list.push({y:s.y, draw:()=>ctx.drawImage(img, fr.sx, fr.sy, fr.w, fr.h, dx, dy, dw, dh)}); }
        for(const t of decorRuntime.torches){ const fr=(torchFramesCache.get((t.anim||'idle'))||[])[t.fi]||(torchFramesCache.get((t.anim||'idle'))||[])[0]; if(!fr||!torchImg) continue; const dw=fr.w*t.scale, dh=fr.h*t.scale; const dx=Math.round(t.x-0.5*dw), dy=Math.round(t.y-dh); list.push({y:t.y, draw:()=>ctx.drawImage(torchImg, fr.sx, fr.sy, fr.w, fr.h, dx, dy, dw, dh)}); }
        for(const b of decorRuntime.buildings){ const img=b.img; if(!img) continue; const dw=img.width*(b.scale||1), dh=img.height*(b.scale||1); const dx=Math.round(b.x-0.5*dw), dy=Math.round(b.y-dh); list.push({y:b.y, draw:()=>ctx.drawImage(img, dx, dy, dw, dh)}); }
        // Insert warrior
        list.push({ y: warrior.y, draw:()=> warrior.draw(ctx) });
        // Draw goal pointer (pulsating)
        if(goalMeta && goalImg && window.tileSize){
          const ts = window.tileSize || goalMeta.tileSize || 64;
          const x = goalMeta.goal && Number.isFinite(goalMeta.goal.c) ? (goalMeta.goal.c * ts + ts/2) : null;
          const y = goalMeta.goal && Number.isFinite(goalMeta.goal.r) ? (goalMeta.goal.r * ts + ts/2) : null;
          if(x!=null && y!=null){
            const s = 0.9 + 0.1*Math.sin((goalPulse||0)/400);
            const dw = goalImg.width * s * 0.6; const dh = goalImg.height * s * 0.6;
            const dx = Math.round(x - dw/2); const dy = Math.round(y - dh/2);
            list.push({ y, draw:()=> ctx.drawImage(goalImg, dx, dy, dw, dh) });
          }
        }
        list.sort((a,b)=> a.y - b.y);
        for(const it of list) it.draw();
      }catch(_){
        // graceful fallback: draw warrior only so overlay tetap terlihat
        warrior.draw(ctx);
      }
    }
  };
  scene.add(decorObj);

  // Load from map if already available, else wait for event
  if(window.__gvp4_map){ try{ await decorRuntime.fromMap(window.__gvp4_map); }catch(_){ } }
  window.addEventListener('gvp4:mapLoaded', async (e)=>{ try{ await decorRuntime.fromMap((e.detail||{}).map||window.__gvp4_map||{}); }catch(_){ } });

  // Quick switch tileset variants with keys 1/2/3
  window.addEventListener('keydown', async (e)=>{
    if(e.key==='1'){ await TerrainEngine.setVariant('color1'); TerrainEngine.render(); }
    if(e.key==='2'){ await TerrainEngine.setVariant('color2'); TerrainEngine.render(); }
    if(e.key==='3'){ await TerrainEngine.setVariant('color3'); TerrainEngine.render(); }
  });
</script>
</body>
</html>
