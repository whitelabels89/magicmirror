<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>D2 - Apple Counting Game</title>
<style>
  body {
    position: relative;
    font-family: Arial, sans-serif;
    text-align: center;
    margin: 20px;
  }
  #connector-svg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }
  .container {
    display: flex;
    flex-direction: column;
    gap: 15px;
    align-items: center;
  }
  .apple-group, .drop-circle, .dice {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 60px;
  }
  .apples {
    font-size: 32px;
    user-select: none;
    display: flex;
    flex-direction: column;
    align-items: center;
    line-height: 1.2;
  }
  /*
  .drop-circle {
    margin-top: 30px;
    width: 50px;
    height: 50px;
    border: 2px solid #555;
    border-radius: 50%;
    line-height: 50px;
    font-size: 24px;
    color: #222;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .drop-circle.correct {
    border-color: green;
    background-color: #c8f7c5;
    color: green;
    font-weight: bold;
  }
  .drop-circle.incorrect {
    border-color: red;
    background-color: #f7c5c5;
    color: red;
    font-weight: bold;
  }
  */
  .answer-circle {
    width: 70px;
    height: 70px;
    background-color: #007bff;
    color: #fff;
    font-size: 32px;
    font-weight: bold;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .dice {
    font-size: 180px;     /* larger die */
    transform: none;
    user-select: none;
    margin-top: -25px;    /* nudge upward */
  }
  .dice-wrapper {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 200px;
  }
  button {
    margin-top: 30px;
    padding: 10px 20px;
    font-size: 18px;
    cursor: pointer;
  }
  .three-column-layout {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 30px;
    justify-items: center;
    margin-top: 20px;
  }
  .apple-group {
    min-width: 100px;
    min-height: 160px;
  }
  .apple-box {
    border: 2px solid #ccc;
    border-radius: 10px;
    padding: 10px;
    margin-bottom: 10px;
    background-color: #fff8f0;
  }

  .question-box {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 15px;
    border: 2px solid #ccc;
    border-radius: 12px;
    background-color: #fff8f0;
    width: 120px;
  }
  .main-layout {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    justify-items: center;
    align-items: start;
    margin-top: 30px;
    gap: 40px;
  }
  .column.number {
    display: flex;
    flex-direction: column;
    justify-content: space-around;
    gap: 20px;
    align-items: center;
    text-align: center;
    height: 100%;
  }

  .column {
    display: flex;
    flex-direction: column;
    gap: 20px;
    align-items: center;
  }

  .apple-container {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    row-gap: 10px;
    column-gap: 10px;
    padding: 5px;
    border: 2px solid #ccc;
    border-radius: 10px;
    width: 200px;
    min-height: 100px;
    background-color: #fff8f0;
    font-size: 48px;
  }

  .item-wrapper {
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .connector-dot {
    width: 12px;
    height: 12px;
    margin: 15px;
    background-color: #000;
    border-radius: 50%;
    cursor: pointer;
  }
  .connector-dot { touch-action: none; }
  body { overscroll-behavior: none; touch-action: manipulation; }
  .connector-dot { position: relative; -webkit-tap-highlight-color: transparent; -webkit-user-select: none; user-select: none; -webkit-user-drag: none; -webkit-touch-callout: none; }
  .connector-dot::after { content: ""; position: absolute; top: -14px; left: -14px; width: 40px; height: 40px; border-radius: 50%; background: transparent; }
  @media (pointer: coarse) {
    .connector-dot { width: 24px; height: 24px; margin: 18px; }
    .connector-dot::after { top: -18px; left: -18px; width: 56px; height: 56px; }
  }
  .connector-dot.selected { outline: 3px solid #2d8cff; box-shadow: 0 0 0 6px rgba(45,140,255,0.2); }
  /* Dice container centered vertically and horizontally */
  .dice-box {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 130px; /* increased to accommodate larger dice */
    padding: 0;    /* no extra padding */
  }
  /* 2.5D Clay-style button */
  .clay-button {
    background-color: #FFD66B;
    border: none;
    border-radius: 24px;
    padding: 12px 28px;
    font-size: 18px;
    color: #333;
    font-weight: bold;
    box-shadow: 0 8px 0 #E6C34E, 0 12px 12px rgba(0,0,0,0.1);
    cursor: pointer;
    transition: transform 0.1s;
  }
  .clay-button:active {
    transform: translateY(6px);
    box-shadow: 0 2px 0 #E6C34E, 0 6px 8px rgba(0,0,0,0.1);
  }
  </style>
<svg id="connector-svg"></svg>
  
</head>
<body>

<h2>Hitung Jumlah Apel dan Sambungkan Angka yang Benar</h2>

<script>
  // Generate 4 random numbers between 1 and 6 inclusive
  let appleCounts = [];
  while (appleCounts.length < 4) {
    let n = Math.floor(Math.random() * 6) + 1;
    appleCounts.push(n);
  }

  // Shuffle function for arrays
  function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
  }
  // Create shuffled answer order
  const shuffledAnswers = appleCounts.slice();
  shuffle(shuffledAnswers);

  const layout = document.createElement('div');
  layout.className = 'main-layout';

  const colApples = document.createElement('div');
  colApples.className = 'column';
  const colDrop = document.createElement('div');
  colDrop.className = 'column number';
  const colDice = document.createElement('div');
  colDice.className = 'column';

  appleCounts.forEach((count, index) => {
    // Apple container with right-hand dot
    const appleBox = document.createElement('div');
    appleBox.className = 'apple-container';
    for (let i = 0; i < count; i++) {
      const apple = document.createElement('div');
      apple.textContent = 'ðŸŽ';
      appleBox.appendChild(apple);
    }
    const appleWrapper = document.createElement('div');
    appleWrapper.className = 'item-wrapper';
    appleWrapper.appendChild(appleBox);
    const appleDot = document.createElement('div');
    appleDot.className = 'connector-dot right';
    appleDot.dataset.count = count;
    appleWrapper.appendChild(appleDot);
    colApples.appendChild(appleWrapper);

    // Dice inside container box, centered, with connector dot on the left outside
    const dice = document.createElement('div');
    dice.className = 'dice';
    dice.textContent = String.fromCharCode(0x267F + count);

    // Connector dot on left
    const diceDot = document.createElement('div');
    diceDot.className = 'connector-dot left';
    diceDot.dataset.count = count;

    // Create dice container box (same style as apple-container) and center the dice
    const diceBox = document.createElement('div');
    diceBox.className = 'apple-container dice-box';
    diceBox.style.display = 'flex';
    diceBox.style.alignItems = 'center';
    diceBox.style.justifyContent = 'center';
    diceBox.appendChild(dice);

    // Wrap dot and dice box together
    const diceContainer = document.createElement('div');
    diceContainer.className = 'item-wrapper';
    diceContainer.appendChild(diceDot);
    diceContainer.appendChild(diceBox);

    colDice.appendChild(diceContainer);
  });

  // Append answer circles in shuffled order
  shuffledAnswers.forEach(count => {
    const answerCircle = document.createElement('div');
    answerCircle.className = 'answer-circle';
    answerCircle.textContent = count;
    const answerWrapper = document.createElement('div');
    answerWrapper.className = 'item-wrapper';
    const dotL = document.createElement('div');
    dotL.className = 'connector-dot left';
    const dotR = document.createElement('div');
    dotR.className = 'connector-dot right';
    answerWrapper.appendChild(dotL);
    answerWrapper.appendChild(answerCircle);
    answerWrapper.appendChild(dotR);
    colDrop.appendChild(answerWrapper);
  });

  layout.appendChild(colApples);
  layout.appendChild(colDrop);
  layout.appendChild(colDice);
  document.body.appendChild(layout);
  // Enable dragging lines between connector dots (mouse & touch friendly)
  (function() {
    const svg = document.getElementById('connector-svg');
    const svgNS = 'http://www.w3.org/2000/svg';
    let tempLine = null;
    let startDot = null;
    let svgRect = null;
    let restoreTouchAction = null;
    let restoreTimer = null;

    function centerOf(dot, rect){
      const b = dot.getBoundingClientRect();
      return { x: b.left + b.width/2 - rect.left, y: b.top + b.height/2 - rect.top };
    }

    function beginDrag(dot, clientX, clientY, moveEvt, endEvt, isTouch, targetEl){
      startDot = dot;
      // disable page gestures during drag (esp. iPad Safari)
      if (isTouch) {
        const prev = document.body.style.touchAction;
        restoreTouchAction = () => { document.body.style.touchAction = prev; restoreTouchAction = null; };
        document.body.style.touchAction = 'none';
        // start watchdog to auto-restore if end/cancel never fires
        if (restoreTimer) clearTimeout(restoreTimer);
        restoreTimer = setTimeout(() => {
          if (restoreTouchAction) restoreTouchAction();
        }, 1500);
      }
      svgRect = svg.getBoundingClientRect();
      tempLine = document.createElementNS(svgNS, 'line');
      tempLine.setAttribute('stroke', '#000');
      tempLine.setAttribute('stroke-width', '2');
      svg.appendChild(tempLine);

      const c = centerOf(startDot, svgRect);
      tempLine.setAttribute('x1', c.x);
      tempLine.setAttribute('y1', c.y);
      tempLine.setAttribute('x2', c.x);
      tempLine.setAttribute('y2', c.y);

      function onMove(e){
        // keep watchdog alive while moving
        if (restoreTimer) { clearTimeout(restoreTimer); }
        restoreTimer = setTimeout(() => { if (restoreTouchAction) restoreTouchAction(); }, 1200);

        if(isTouch){ e.preventDefault(); const t = e.touches[0] || e.changedTouches[0]; if(!t) return; tempLine.setAttribute('x2', t.clientX - svgRect.left); tempLine.setAttribute('y2', t.clientY - svgRect.top); }
        else { tempLine.setAttribute('x2', e.clientX - svgRect.left); tempLine.setAttribute('y2', e.clientY - svgRect.top); }
      }

      function onEnd(e){
        (targetEl || window).removeEventListener(moveEvt, onMove, {passive:false});
        (targetEl || window).removeEventListener(endEvt, onEnd, {passive:false});
        try { startDot && startDot.releasePointerCapture && e.pointerId !== undefined && startDot.releasePointerCapture(e.pointerId); } catch(_){}
        let cx, cy;
        if(isTouch){ const t = (e.changedTouches && e.changedTouches[0]) || (e.touches && e.touches[0]); if(!t){ if(tempLine) svg.removeChild(tempLine); tempLine=null; startDot=null; return; } cx=t.clientX; cy=t.clientY; }
        else { cx=e.clientX; cy=e.clientY; }
        const target = document.elementFromPoint(cx, cy);
        if (target && target.classList.contains('connector-dot') && target !== startDot) {
          // remove existing lines
          if (startDot._line) { svg.removeChild(startDot._line); startDot._line = null; }
          if (target._line)   { svg.removeChild(target._line);   target._line = null; }
          const tC = centerOf(target, svgRect);
          tempLine.setAttribute('x2', tC.x);
          tempLine.setAttribute('y2', tC.y);
          startDot._line = tempLine; startDot._connectedDot = target;
          target._line = tempLine;   target._connectedDot = startDot;
        } else {
          if (tempLine) svg.removeChild(tempLine);
        }
        if (restoreTimer) { clearTimeout(restoreTimer); restoreTimer = null; }
        if (restoreTouchAction) restoreTouchAction();
        tempLine = null; startDot = null;
      }

      (targetEl || window).addEventListener(moveEvt, onMove, {passive:false});
      (targetEl || window).addEventListener(endEvt, onEnd, {passive:false});
    }

    // Allow start from ANY connector dot (left/middle/right)
    const dots = document.querySelectorAll('.connector-dot');

    if (window.PointerEvent) {
      dots.forEach(dot => {
        dot.addEventListener('pointerdown', (e) => {
          // Drag only for mouse; touch/pen will use tap-to-connect
          if (e.pointerType !== 'mouse') return;
          if (e.button !== 0) return;
          e.preventDefault();
          dot.setPointerCapture(e.pointerId);
          beginDrag(dot, e.clientX, e.clientY, 'pointermove', 'pointerup', e.pointerType === 'touch', dot);
        }, {passive:false});
        dot.addEventListener('pointercancel', (e) => {
          // simulate end if pointer is canceled
          const evt = new PointerEvent('pointerup', {pointerId: e.pointerId, clientX: e.clientX, clientY: e.clientY});
          window.dispatchEvent(evt);
        }, {passive:false});
      });
      window.addEventListener('pointerup', (e) => {
        // if a drag is active but somehow no end fired on targetEl, force-restore
        if (restoreTimer && restoreTouchAction && startDot && tempLine) {
          if (restoreTimer) { clearTimeout(restoreTimer); restoreTimer = null; }
          restoreTouchAction();
        }
      }, {passive:false});
    } else {
      // Mouse fallback
      dots.forEach(dot => {
        dot.addEventListener('mousedown', (e) => { e.preventDefault(); beginDrag(dot, e.clientX, e.clientY, 'mousemove', 'mouseup', false); });
      });
      // Touch fallback
      dots.forEach(dot => {
        dot.addEventListener('touchstart', (e) => {
          e.preventDefault();
          const t = e.touches[0];
          if(!t) return;
          beginDrag(dot, t.clientX, t.clientY, 'touchmove', 'touchend', true);
        }, {passive:false});
      });
    }

    // global failsafe: always restore touchAction on blur/visibility change
    window.addEventListener('blur', () => { if (restoreTimer) { clearTimeout(restoreTimer); restoreTimer = null; } if (restoreTouchAction) restoreTouchAction(); });
    document.addEventListener('visibilitychange', () => { if (document.hidden) { if (restoreTimer) { clearTimeout(restoreTimer); restoreTimer = null; } if (restoreTouchAction) restoreTouchAction(); } });

    // extra safety: global touch listeners during drag on iOS
    window.addEventListener('touchmove', function(e){ if (tempLine) { e.preventDefault(); } }, {passive:false});
    // === TAP-TO-CONNECT MODE (for coarse pointers / touch & pen) ===
    (function(){
      const svg = document.getElementById('connector-svg');
      const svgNS = 'http://www.w3.org/2000/svg';
      let selectedDot = null;

      function centerOf(dot, rect){
        const b = dot.getBoundingClientRect();
        return { x: b.left + b.width/2 - rect.left, y: b.top + b.height/2 - rect.top };
      }

      function clearSelected(){
        if(selectedDot){ selectedDot.classList.remove('selected'); selectedDot = null; }
      }

      function connectDots(a,b){
        const rect = svg.getBoundingClientRect();
        // remove previous lines on both ends and clear partner locks
        if (a._line) { try{svg.removeChild(a._line);}catch(_){} a._line=null; if (a._connectedDot){ a._connectedDot._line=null; a._connectedDot._connectedDot=null; a._connectedDot._locked=false; a._connectedDot._isStart=false; } }
        if (b._line) { try{svg.removeChild(b._line);}catch(_){} b._line=null; if (b._connectedDot){ b._connectedDot._line=null; b._connectedDot._connectedDot=null; b._connectedDot._locked=false; b._connectedDot._isStart=false; } }
        const line = document.createElementNS(svgNS, 'line');
        line.setAttribute('stroke', '#000');
        line.setAttribute('stroke-width', '2');
        const ac = centerOf(a, rect);
        const bc = centerOf(b, rect);
        line.setAttribute('x1', ac.x); line.setAttribute('y1', ac.y);
        line.setAttribute('x2', bc.x); line.setAttribute('y2', bc.y);
        svg.appendChild(line);
        a._line = line; a._connectedDot = b;
        b._line = line; b._connectedDot = a;
        a._isStart = true; b._isStart = false;
        a._locked = true; b._locked = true;
      }

      function handleTap(e){
        const dot = e.currentTarget;
        // FIRST TAP
        if(!selectedDot){
          // if this dot is already locked, only allow re-activation if it's the original start dot
          if (dot._locked) {
            if (dot._isStart) {
              // reactivate correction mode: remove current line and unlock both ends
              const partner = dot._connectedDot;
              if (dot._line) { try{svg.removeChild(dot._line);}catch(_){} }
              if (partner) { partner._line=null; partner._connectedDot=null; partner._locked=false; partner._isStart=false; }
              dot._line=null; dot._connectedDot=null; dot._locked=false; // keep _isStart true for semantic, but selection governs behavior
            } else {
              // tapping end point does nothing when locked
              return;
            }
          }
          selectedDot = dot;
          selectedDot.classList.add('selected');
          return;
        }
        // SECOND TAP: if tapping the same selected dot, clear selection
        if(selectedDot === dot){ clearSelected(); return; }
        // If target is locked and is not the original start, ignore to avoid altering existing connection
        if (dot._locked && !dot._isStart) { clearSelected(); return; }
        // Connect and clear selection
        connectDots(selectedDot, dot);
        clearSelected();
      }

      // Attach tap handlers on all dots
      const dots = document.querySelectorAll('.connector-dot');
      dots.forEach(d => {
        // Mouse: click is fine
        d.addEventListener('click', handleTap, {passive:true});
        // Touch: fast path without long-press delay
        d.addEventListener('touchend', function(ev){ handleTap(ev); }, {passive:true});
        // Stylus/Pen: trigger immediately on pointerup (no long-press)
        d.addEventListener('pointerup', function(ev){
          if (ev.pointerType && ev.pointerType !== 'mouse') handleTap(ev);
        }, {passive:true});
        // Prevent long-press context menu interfering on iPad
        d.addEventListener('contextmenu', function(e){ e.preventDefault(); }, {passive:false});
      });

      // If user taps outside, clear selection
      document.addEventListener('click', (ev)=>{
        const t = ev.target;
        if(!t || !t.classList || !t.classList.contains('connector-dot')) clearSelected();
      }, {passive:true});
    })();
  })();

  // Check answers: verify each answer circle is connected correctly after DOM loads
  window.addEventListener('DOMContentLoaded', () => {
    document.getElementById('check-btn').addEventListener('click', () => {
      let allCorrect = true;
      document.querySelectorAll('.column.number .item-wrapper').forEach(wrapper => {
        const count = parseInt(wrapper.querySelector('.answer-circle').textContent);
        const leftDot = wrapper.querySelector('.connector-dot.left');
        const rightDot = wrapper.querySelector('.connector-dot.right');
        const correctLeft = leftDot._connectedDot && leftDot._connectedDot.dataset.count == count;
        const correctRight = rightDot._connectedDot && rightDot._connectedDot.dataset.count == count;
        const circle = wrapper.querySelector('.answer-circle');
        if (correctLeft || correctRight) {
          circle.style.border = '3px solid green';
        } else {
          circle.style.border = '3px solid red';
          allCorrect = false;
        }
      });
      if (allCorrect) alert('Semua jawaban benar!');
    });
  });
</script>

<button id="check-btn" class="clay-button">Periksa Jawaban</button>

<script type="module">
  import { addFinishButton } from '/elearn/worlds/utils/finish-button.js';
  addFinishButton('calistung','Level 11','/elearn/calistung/level/E1.html');
</script>
</body>
</html>
