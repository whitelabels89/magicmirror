<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hologram Head â€“ Ultra Real</title>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;background:#071312;color:#eafbf6;overflow:hidden}
    /* Premium backdrop */
    body{
      background:
        radial-gradient(1600px 720px at 50% -12%, #112c2a 0%, #0a1918 60%, #050c0b 100%),
        radial-gradient(600px 260px at 8% 10%, rgba(54,225,198,.08), transparent 65%),
        radial-gradient(800px 320px at 92% 88%, rgba(124,255,178,.06), transparent 70%);
    }
    #app{position:fixed; inset:0}
    canvas{display:block}
    /* UI hint */
    .hint{position:fixed; left:20px; bottom:18px; opacity:.65; font:500 12px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, 'Helvetica Neue', Arial}
    .hint kbd{padding:2px 6px; border:1px solid #2b4946; border-radius:6px; background:#0b1f1d; color:#dff9f3}
    /* === Legend HUD toggle (tiny) === */
    .hint{ display:none !important; }
    body.show-hint .hint{ display:block !important; }

    /* Tiny floating toggle button */
    .hint-toggle{
      position: fixed; left: 12px; bottom: 12px; z-index: 9999;
      width: 28px; height: 28px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,.28);
      background: linear-gradient(135deg, rgba(255,255,255,.14), rgba(255,255,255,.06));
      color: #dff9f3; font-weight: 700; font-size: 14px; line-height: 1;
      display: grid; place-items: center; cursor: pointer;
      box-shadow: 0 6px 16px rgba(0,0,0,.35);
    }
    .hint-toggle:hover{ transform: translateY(-1px); }
    .hint-toggle[aria-pressed="true"]{ border-color: rgba(124,255,178,.6); box-shadow: 0 0 0 1px rgba(124,255,178,.25) inset, 0 8px 20px rgba(124,255,178,.25); }
    @media (max-width: 768px){ .hint-toggle{ left: 10px; bottom: 10px; width: 26px; height: 26px; font-size: 13px; } }

    /* === Mic toggle (tiny) === */
    .mic-toggle{
      position: fixed; right: 12px; bottom: 12px; z-index: 9999;
      width: 30px; height: 30px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,.28);
      background: linear-gradient(135deg, rgba(255,255,255,.14), rgba(255,255,255,.06));
      color: #eafbf6; font-size: 14px; line-height: 1; font-weight: 700;
      display: grid; place-items: center; cursor: pointer;
      box-shadow: 0 6px 16px rgba(0,0,0,.35);
    }
    .mic-toggle:hover{ transform: translateY(-1px); }
    .mic-toggle[aria-pressed="true"]{
      border-color: rgba(197,143,255,.7);
      box-shadow: 0 0 0 1px rgba(197,143,255,.35) inset,
                  0 0 16px rgba(197,143,255,.35),
                  0 8px 22px rgba(0,0,0,.35);
    }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="app"></div>
  <div class="hint">Drag = look Â· <kbd>G</kbd> glow Â· <kbd>L</kbd> lines Â· <kbd>S</kbd> scan Â· <kbd>F</kbd> flow Â· [ ] density Â· , . size Â· - = speed Â· <kbd>B</kbd>/<kbd>C</kbd> boost/contrast Â· <kbd>4</kbd> switch Â· <kbd>6</kbd> tesla Â· <kbd>Shift+R</kbd> reload</div>
  <button id="hint-toggle" class="hint-toggle" aria-pressed="false" title="Show controls">?</button>
  <button id="mic-toggle" class="mic-toggle" aria-pressed="false" title="Enable mic">ðŸŽ¤</button>

  <script type="module">
  import * as THREE from 'three';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
  // ==========================
  // Realistic Hologram Head (no external model):
  // - Lathe head geometry (stylized human head)
  // - Custom shader stripes + fresnel glow (horizontal lines like reference)
  // - Dynamic point cloud shimmer
  // - Subtle camera parallax and drag look
  // ==========================
  (function(){
    // Dev cache buster for GLB (browser caches aggressively)
    let __glbCacheToken = Date.now();
    function withCacheBust(url){
      const isLocal = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
      if(!isLocal) return url; // only bust on local dev
      const sep = url.includes('?') ? '&' : '?';
      return url + sep + 'v=' + (__glbCacheToken++);
    }
    const host = document.getElementById('app');
    const W = host.clientWidth, H = host.clientHeight, DPR = Math.min(2, window.devicePixelRatio||1);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(18, W/H, 0.1, 100); // tighter FOV for natural zoom-in
    camera.position.set(0, 0.18, 4.0);

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(DPR); renderer.setSize(W,H); renderer.setClearColor(0x000000, 0);
    host.appendChild(renderer.domElement);

    // === Mic (beat) reactive setup ===
    let MIC = { ctx:null, analyser:null, data:null, level:0, ready:false, enabled:false };
    async function initMic(){
      try{
        const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation:true, noiseSuppression:true } });
        const ctx = new (window.AudioContext||window.webkitAudioContext)();
        const src = ctx.createMediaStreamSource(stream);
        const analyser = ctx.createAnalyser();
        analyser.fftSize = 512; // 256 bins
        analyser.smoothingTimeConstant = 0.82;
        src.connect(analyser);
        MIC.ctx = ctx; MIC.analyser = analyser; MIC.data = new Uint8Array(analyser.frequencyBinCount); MIC.ready = true;
      }catch(err){ console.warn('Mic init failed:', err); }
    }

    // Tiny toast helper (bottom-right)
    function micToast(msg){
      const el = document.createElement('div');
      el.textContent = msg;
      el.style.cssText = 'position:fixed;right:12px;bottom:52px;background:#0b1f1d;border:1px solid #2b4946;color:#dff9f3;padding:8px 10px;border-radius:8px;z-index:10000;font:600 12px system-ui;opacity:0;transform:translateY(6px);transition:opacity .18s ease, transform .18s ease;';
      document.body.appendChild(el);
      requestAnimationFrame(()=>{ el.style.opacity = '0.96'; el.style.transform = 'translateY(0)'; });
      setTimeout(()=>{ el.style.opacity = '0'; el.style.transform = 'translateY(6px)'; }, 1400);
      setTimeout(()=>{ el.remove(); }, 2000);
    }

    // Lighting is minimal; most look comes from shader emissive/fresnel
    const rig = new THREE.Group();
    // Global model vertical offset (raise/lower all variants together)
    const MODEL_Y_OFFSET = 0.28; // â†‘ raise model ~0.28 units
    scene.add(rig);

    // === Shader material for horizontal stripes + fresnel glow
    const uniforms = {
      uTime: { value: 0 },
      uColorA: { value: new THREE.Color(0x7cffb2) },
      uColorB: { value: new THREE.Color(0x36e1c6) },
      uStripeDensity: { value: 110.0 },   // number of lines along height
      uStripeSmooth: { value: 0.75 },     // softness of band edges
      uGlow: { value: 0.0 },
      uLineStrength: { value: 0.95 },
      uViewPos: { value: camera.position.clone() },
      uScanOn: { value: 1.0 },        // scan band on/off
      uScanWidth: { value: 0.19 },    // scan band width
      uScanSpeed: { value: 1.3 },     // scan speed
      uFlowOn: { value: 1.0 },      // surface-following hologram flow
      uFlowSpeed: { value: 1.4 },    // updated default
      uFlowDensity: { value: 14.0 }, // updated pulses across surface
      uGlyphSize: { value: 0.46 },   // thicker glyph stripes
      uFlowBoost: { value: 1.6 },    // brightness boost for flow
      uFlowContrast: { value: 2.2 }, // sharpen flow edges
    };

    const vert = `
      varying vec3 vPos; varying vec3 vNormal; varying vec3 vWorld; 
      void main(){
        vPos = position; vNormal = normalize(normalMatrix * normal);
        vec4 worldPos = modelMatrix * vec4(position,1.0); vWorld = worldPos.xyz;
        gl_Position = projectionMatrix * viewMatrix * worldPos;
      }
    `;

    // Simple hash noise
    const noise = `
      float hash12(vec2 p){ vec3 p3 = fract(vec3(p.xyx) * 0.1031);
        p3 += dot(p3, p3.yzx + 33.33); return fract((p3.x + p3.y) * p3.z);
      }
    `;

    const frag = `
  precision highp float; varying vec3 vPos; varying vec3 vNormal; varying vec3 vWorld;
  uniform float uTime; uniform vec3 uColorA; uniform vec3 uColorB;
  uniform float uStripeDensity; uniform float uStripeSmooth; uniform float uGlow; uniform float uLineStrength; uniform vec3 uViewPos;
  uniform float uScanOn; uniform float uScanWidth; uniform float uScanSpeed;
  uniform float uFlowOn; uniform float uFlowSpeed; uniform float uFlowDensity; uniform float uGlyphSize; uniform float uFlowBoost; uniform float uFlowContrast;

  float hash12(vec2 p){ vec3 p3 = fract(vec3(p.xyx) * 0.1031); p3 += dot(p3, p3.yzx + 33.33); return fract((p3.x + p3.y) * p3.z); }

  // TBN from screen-space derivatives to align effects to surface
  void makeTBN(in vec3 worldPos, out vec3 T, out vec3 B, out vec3 N){
    vec3 dpx = dFdx(worldPos); vec3 dpy = dFdy(worldPos);
    N = normalize(cross(dpx, dpy));
    vec3 ref = (abs(N.y) < 0.75) ? vec3(0.0,1.0,0.0) : vec3(1.0,0.0,0.0);
    T = normalize(ref - N * dot(ref, N));
    B = normalize(cross(N, T));
  }

  // Thin moving pulse pattern along 1D coordinate (returns 1 at line center)
  float pulse(float x, float width){
    float f = abs(fract(x) - 0.5);
    // steeper edge for high-contrast lines
    return 1.0 - smoothstep(0.5 - width, 0.5, f);
  }

  void main(){
    vec3 V = normalize(uViewPos - vWorld);
    vec3 T, B, N; makeTBN(vWorld, T, B, N);
    float fres = pow(1.0 - max(dot(normalize(N), V), 0.0), 2.0);

    // ===== Base dynamic horizontal stripes (background texture)
    float y = vWorld.y * uStripeDensity + uTime*12.0;
    float band = abs(fract(y) - 0.5);
    float stripes = smoothstep(0.45, 0.45 - uStripeSmooth*0.45, band);
    float n = hash12(vWorld.xz * 3.5 + uTime*0.05);
    float twinkle = 0.85 + 0.35 * sin(uTime*2.0 + vWorld.x*4.0 + vWorld.y*3.0);
    stripes = clamp(stripes * uLineStrength * mix(0.78, 1.22, n) * twinkle, 0.0, 1.0);

    // ===== Surface-aligned flowing glyphs (very visible)
    float u = dot(vWorld, T) * uFlowDensity + uTime * uFlowSpeed;
    float v = dot(vWorld, B) * uFlowDensity - uTime * (uFlowSpeed * 0.65);
    // Two interleaved lanes to look like "code"
    float flowU = pulse(u, uGlyphSize);
    float flowV = pulse(v + 0.33, uGlyphSize * 0.84);
    float flow = max(flowU, flowV) * uFlowOn;
    // Sharpen and boost
    flow = pow(clamp(flow, 0.0, 1.0), uFlowContrast);
    float flowGlow = smoothstep(0.0, 1.0, flow) * uFlowBoost;

    // ===== Optional scan band (kept subtle)
    float scanCenter = -1.2 + mod(uTime * uScanSpeed, 2.4);
    float d = abs(vWorld.y - scanCenter);
    float scanBand = (1.0 - smoothstep(uScanWidth, uScanWidth*1.8, d)) * uScanOn;

    // Compose color: stripes base
    vec3 base = mix(uColorB, uColorA, stripes);
    // Add bright cyan-violet flow tint so it pops
    vec3 flowTint = vec3(0.85, 1.00, 1.25);
    base += flowGlow * flowTint;

    // Rim and scan
    base += fres * uGlow * 0.85;
    base = mix(base, base * vec3(1.12,1.08,1.22), scanBand * 0.75);

    // Depth vignette
    float vignY = smoothstep(0.0, 0.6, abs(vWorld.y)*0.5);
    base *= mix(0.7, 1.0, 1.0 - vignY);

    // Make alpha react to flow so moving code is unmistakable
    float a = mix(0.82, 0.98, max(scanBand, flow*0.85));
    gl_FragColor = vec4(base, a);
  }
`;

    // === Fallback: procedural head (lathe) if GLB invalid (e.g., sphere)
    function createFallbackHead(){
      const pts = [];
      for(let i=0;i<=96;i++){
        const t = i/96;                 // 0..1 chin->crown
        const y = -1.22 + 2.44*t;       // total height ~2.44
        let r = 0.56 + 0.46*Math.sin(Math.PI*t);
        if(t<0.22) r *= 0.64 + 0.62*t;            // jaw+chin
        if(t>0.74) r *= 1.06 - 0.62*(t-0.74)/0.26;// forehead taper
        if(t<0.08) r *= 0.48;                      // neck
        pts.push(new THREE.Vector2(r, y));
      }
      const g = new THREE.LatheGeometry(pts, 320);
      g.rotateX(Math.PI*0.03);
      g.computeVertexNormals();
      const m = new THREE.ShaderMaterial({ uniforms, vertexShader: vert, fragmentShader: frag, transparent:true, depthWrite:false, depthTest:false, side: THREE.DoubleSide });
      const mesh = new THREE.Mesh(g, m);
      mesh.scale.set(0.92, 1.0, 1.06);
      return mesh;
    }

    // === Reusable GLB loader with auto-center/scale and fallback
    let currentHead = null;
    const loader = new GLTFLoader();
    // Shim: ignore legacy/unsupported material extensions (we override materials anyway)
    loader.register((parser)=>({ name: 'KHR_materials_pbrSpecularGlossiness' }));
    loader.register((parser)=>({ name: 'KHR_materials_common' }));

    function clearHead(){
      if(currentHead){ rig.remove(currentHead); currentHead.traverse?.(o=>{ if(o.geometry) o.geometry.dispose?.(); if(o.material){ if(o.material.map) o.material.map.dispose?.(); o.material.dispose?.(); }}); currentHead = null; }
    }

    function loadHead(url){
      clearHead();
      const badge = document.createElement('div');
      badge.style.cssText = 'position:fixed;left:16px;top:16px;background:#0b1f1d;border:1px solid #2b4946;color:#dff9f3;padding:8px 10px;border-radius:8px;z-index:10000;font:500 12px system-ui;opacity:.9';
      const finalURL = withCacheBust(url);
      badge.textContent = `Loading ${finalURL} ...`; document.body.appendChild(badge);

      loader.load(finalURL, (gltf)=>{
        const head = gltf.scene;
        let meshCount=0, skinnedCount=0;
        head.traverse((child)=>{
          if(child.isMesh || child.isSkinnedMesh){
            meshCount++; if(child.isSkinnedMesh) skinnedCount++;
            if(child.isSkinnedMesh){
              child.material = new THREE.MeshBasicMaterial({ color: 0x7cffb2, wireframe:true, transparent:true, opacity:0.9, side: THREE.DoubleSide, depthTest:false, depthWrite:false });
            } else {
              child.material = new THREE.ShaderMaterial({
                uniforms, vertexShader: vert, fragmentShader: frag,
                transparent:true, depthWrite:false, depthTest:false, side: THREE.DoubleSide
              });
            }
            child.castShadow = child.receiveShadow = false; child.frustumCulled=false; child.renderOrder=1;
          }
        });

        // Add a points shimmer overlay on top of each non-skinned mesh
        head.traverse((child)=>{
          if(child.isMesh && !child.isSkinnedMesh){
            const geo = child.geometry;
            const pts = new THREE.Points(
              geo,
              new THREE.PointsMaterial({ color: 0x7cffb2, size: 0.016, sizeAttenuation: true, transparent:true, opacity:0.9 })
            );
            // Match transform
            pts.position.copy(child.position); pts.rotation.copy(child.rotation); pts.scale.copy(child.scale);
            // Render after mesh
            pts.renderOrder = 2; pts.frustumCulled = false; pts.userData._isShimmer = true;
            child.add(pts);
          }
        });

        // Auto center/scale
        const preBox = new THREE.Box3().setFromObject(head);
        const size = new THREE.Vector3(); preBox.getSize(size);
        const center = new THREE.Vector3(); preBox.getCenter(center);
        head.position.sub(center);
        const targetH = 2.9; const s = (size.y>0.0001)? (targetH/size.y) : 1.0; head.scale.setScalar(s);
        const box = new THREE.Box3().setFromObject(head); const minY = box.min.y; head.position.y += (-1.2 - minY);
        head.position.y += MODEL_Y_OFFSET; // apply global vertical offset

        // Sphere/placeholder detection (more lenient)
        const aspectXY = Math.abs(size.x - size.y) / Math.max(size.x, size.y);
        const aspectYZ = Math.abs(size.y - size.z) / Math.max(size.y, size.z);
        const isNearSphere = (aspectXY < 0.03) && (aspectYZ < 0.03);
        const likelySphereByName = (gltf.scene.name||'').toLowerCase().includes('sphere');
        if(isNearSphere || likelySphereByName || meshCount===0){
          const toast = document.createElement('div');
          toast.style.cssText = 'position:fixed;right:16px;top:16px;background:#3a1f1f;border:1px solid #a85d5d;color:#ffdede;padding:10px 12px;border-radius:8px;z-index:10000;font:500 12px system-ui';
          toast.textContent = `${finalURL} looks like a sphere/empty. Using procedural fallback.`; document.body.appendChild(toast); setTimeout(()=>toast.remove(), 4200);
          const fallback = createFallbackHead(); fallback.position.y = -0.2; currentHead=fallback; rig.add(fallback);
          badge.textContent = `Loaded: ${finalURL} â†’ fallback (meshes: ${meshCount}${skinnedCount?` skinned:${skinnedCount}`:''})`;
          setTimeout(()=>badge.remove(), 3500);
          return;
        }

        // Face toward camera if needed + proportion tweak
        if(size.z > size.x * 1.2){ head.rotation.y = Math.PI; }
        head.scale.x *= 0.92; head.scale.z *= 1.06;

        currentHead = head; rig.add(head);
        // === Force-visible helpers & diagnostics
        // 1) Fit camera z based on bounding sphere (for safety)
        const sphere = new THREE.Sphere();
        new THREE.Box3().setFromObject(head).getBoundingSphere(sphere);
        if(isFinite(sphere.radius) && sphere.radius>0){
          const desired = sphere.radius / Math.tan((camera.fov * Math.PI/180) / 2) + 0.4; // smaller padding
          camera.position.z = Math.min(12, Math.max(2.2, desired * 0.9));
        }

        // 2) Show a Box3 helper briefly so we know where the model sits
        const helperBox = new THREE.Box3Helper(new THREE.Box3().setFromObject(head), 0x00ffcc);
        helperBox.material.transparent = true; helperBox.material.opacity = 0.25; helperBox.renderOrder = 10;
        rig.add(helperBox);
        setTimeout(()=>{ helperBox.visible = false; }, 4000);

        // 3) If somehow size is tiny, upscale again aggressively
        const finalBox = new THREE.Box3().setFromObject(head);
        const finalSize = new THREE.Vector3(); finalBox.getSize(finalSize);
        if(finalSize.y < 0.2){
          const boost = 0.2 / Math.max(1e-6, finalSize.y);
          head.scale.multiplyScalar(boost);
        }

        // 4) Persistent HUD (until next load) with final numbers
        const hud = document.createElement('div');
        hud.style.cssText = 'position:fixed;left:16px;top:44px;background:#0b1f1d;border:1px solid #2b4946;color:#dff9f3;padding:8px 10px;border-radius:8px;z-index:10000;font:500 12px system-ui;opacity:.9';
        hud.textContent = `Final bbox: ${finalSize.x.toFixed(2)} Ã— ${finalSize.y.toFixed(2)} Ã— ${finalSize.z.toFixed(2)} | camZ:${camera.position.z.toFixed(2)}`;
        document.body.appendChild(hud);
        setTimeout(()=>hud.remove(), 4500);
        badge.textContent = `Loaded: ${finalURL} âœ“ meshes:${meshCount}${skinnedCount?` (skinned:${skinnedCount})`:''} sizeY:${size.y.toFixed(2)} â†’ scale:${s.toFixed(3)}`;
        setTimeout(()=>badge.remove(), 3500);
      }, undefined, (err)=>{
        console.error('GLB load error', err);
        badge.textContent = `Failed to load ${finalURL}`; setTimeout(()=>badge.remove(), 4000);
        const msg = document.createElement('div');
        msg.style.cssText = 'position:fixed;right:16px;top:16px;background:#0b1f1d;border:1px solid #2b4946;color:#dff9f3;padding:10px 12px;border-radius:8px;z-index:10000;font:500 12px system-ui';
        msg.textContent = `Failed to load ${finalURL} â€“ check path & server static config`;
        document.body.appendChild(msg); setTimeout(()=>msg.remove(), 5000);
      });
    }

    // === Procedural Variant: Tesla Orb (abstract AI core) â€” defined inside module scope
    function loadTesla(){
      clearHead();
      // Init mic only when user enables it
      if(MIC.enabled && !MIC.ready){ initMic(); }
      const grp = new THREE.Group(); grp.name = 'TeslaOrb';

      const teslaUniforms = {
        uTime: uniforms.uTime,
        uColorA: uniforms.uColorA,
        uColorB: uniforms.uColorB,
        uRim: { value: 1.0 },
        uArcThresh: { value: 0.78 },
        uGlow: { value: 1.2 }
      };
      const teslaVert = `
        varying vec3 vW; varying vec3 vN; 
        void main(){ vN = normalize(normalMatrix * normal); vec4 wp = modelMatrix * vec4(position,1.0); vW = wp.xyz; gl_Position = projectionMatrix * viewMatrix * wp; }
      `;
      const teslaFrag = `
        precision highp float; varying vec3 vW; varying vec3 vN; 
        uniform float uTime; uniform vec3 uColorA; uniform vec3 uColorB; uniform float uRim; uniform float uArcThresh; uniform float uGlow;
        float h33(vec3 p){ p = fract(p*0.3183099+vec3(0.1,0.2,0.3)); p += dot(p,p.yzx+19.19); return fract(p.x*p.y*p.z*(p.x+p.y+p.z)); }
        float noise3(vec3 p){ vec3 i=floor(p), f=fract(p); f=f*f*(3.0-2.0*f); 
          float n = mix(mix(mix(h33(i+vec3(0,0,0)),h33(i+vec3(1,0,0)),f.x),mix(h33(i+vec3(0,1,0)),h33(i+vec3(1,1,0)),f.x),f.y),
                         mix(mix(h33(i+vec3(0,0,1)),h33(i+vec3(1,0,1)),f.x),mix(h33(i+vec3(0,1,1)),h33(i+vec3(1,1,1)),f.x),f.y),f.z);
          return n; }
        void main(){
          vec3 N = normalize(vN);
          float rim = pow(1.0 - abs(N.z), 2.0) * uRim;
          float t = uTime*1.6; 
          float n = 0.0; 
          n += noise3(N*6.0 + vec3(0.0,t*0.5,0.0));
          n += 0.5*noise3(N*12.0 + vec3(t*0.2,0.0,0.0));
          n += 0.25*noise3(N*24.0 + vec3(0.0,0.0,t*0.35));
          float arc = smoothstep(uArcThresh, 1.0, n);
          vec3 col = mix(uColorB, uColorA, arc);
          col += rim*vec3(0.9,1.0,1.2)*0.8;
          col *= 0.8 + 0.5*arc;
          float a = 0.65 + 0.35*arc + rim*0.2;
          gl_FragColor = vec4(col, a);
        }
      `;
      const g = new THREE.SphereGeometry(1.0, 160, 160);
      const m = new THREE.ShaderMaterial({ uniforms: teslaUniforms, vertexShader: teslaVert, fragmentShader: teslaFrag, transparent:true, side:THREE.DoubleSide, depthWrite:false, depthTest:false });
      const orb = new THREE.Mesh(g, m); grp.add(orb);
      const e = new THREE.EdgesGeometry(new THREE.SphereGeometry(1.0, 32, 32));
      const l = new THREE.LineSegments(e, new THREE.LineBasicMaterial({ color:0xB388FF, transparent:true, opacity:0.20 }));
      grp.add(l);
      const core = new THREE.Mesh(new THREE.SphereGeometry(0.38, 64, 64), new THREE.MeshBasicMaterial({ color:0x9ffff0, transparent:true, opacity:0.65 }));
      grp.add(core);
      core.userData._isCore = true;

      // === Inner lightning (core â†’ shell) ===
      const inner = new THREE.Group();
      grp.add(inner);
      const rCore = 0.40, rShell = 1.06;
      function makeInnerCurve(){
        const a = randomPointOnSphere(rCore);
        const b = randomPointOnSphere(rShell);
        const dir = a.clone().normalize();
        const c1 = a.clone().add(dir.clone().multiplyScalar(0.35 + Math.random()*0.35));
        const mid = a.clone().add(b).multiplyScalar(0.5);
        const c2 = mid.clone().normalize().multiplyScalar(0.6 + Math.random()*0.4);
        return { a, b, c1, c2 };
      }
      function buildInnerGeom(curve, segments){
        const pts = new Float32Array((segments+1)*3);
        for(let i=0;i<=segments;i++){
          const t = i/segments; // cubic Bezier
          const it = 1.0 - t;
          const p = new THREE.Vector3().set(0,0,0)
            .addScaledVector(curve.a, it*it*it)
            .addScaledVector(curve.c1, 3.0*it*it*t)
            .addScaledVector(curve.c2, 3.0*it*t*t)
            .addScaledVector(curve.b, t*t*t);
          pts[i*3+0]=p.x; pts[i*3+1]=p.y; pts[i*3+2]=p.z;
        }
        const g = new THREE.BufferGeometry(); g.setAttribute('position', new THREE.BufferAttribute(pts,3)); return g;
      }
      function spawnInner(){
        const curve = makeInnerCurve();
        const segs = 44 + Math.floor(Math.random()*22);
        const geom = buildInnerGeom(curve, segs);
        const line = new THREE.Line(geom, new THREE.LineBasicMaterial({ color: 0x8A5BFF, transparent:true, opacity:0.0, depthWrite:false, blending: THREE.AdditiveBlending }));
        const line2 = new THREE.Line(geom.clone(), new THREE.LineBasicMaterial({ color: 0x58C7FF, transparent:true, opacity:0.0, depthWrite:false, blending: THREE.AdditiveBlending }));
        line2.scale.multiplyScalar(1.008);
        const g = new THREE.Group(); g.add(line); g.add(line2);
        g.userData.life = 0; g.userData.max = 260 + Math.floor(Math.random()*360);
        g.userData.jitter = ()=>{
          const pos = g.children[0].geometry.attributes.position; const cnt = pos.count;
          for(let i=1;i<cnt-1;i++){ // keep endpoints anchored
            const j = 0.0065; const jx = (Math.random()-0.5)*j, jy=(Math.random()-0.5)*j, jz=(Math.random()-0.5)*j;
            pos.setXYZ(i, pos.getX(i)+jx, pos.getY(i)+jy, pos.getZ(i)+jz);
          }
          pos.needsUpdate = true;
          const pos2 = g.children[1].geometry.attributes.position; pos2.array.set(pos.array); pos2.needsUpdate = true;
        };
        inner.add(g);
      }
      // Pre-fill inner arcs
      for(let i=0;i<10;i++) spawnInner();
      grp.userData.inner = inner;
      grp.userData.spawnInner = spawnInner;

      // === Tesla lightning bolts (animated) ===
      const bolts = new THREE.Group();
      grp.add(bolts);

      function randUnit(){ return (Math.random()*2-1); }
      function randomPointOnSphere(r){
        let v = new THREE.Vector3(randUnit(), randUnit(), randUnit());
        v.normalize().multiplyScalar(r); return v;
      }
      function makeBoltCurve(){
        const a = randomPointOnSphere(1.06);
        const b = randomPointOnSphere(1.06);
        const mid = a.clone().add(b).multiplyScalar(0.5);
        const lift = mid.clone().normalize().multiplyScalar(0.45 + Math.random()*0.55); // stronger lift â†’ longer arc
        const c = mid.clone().add(lift);
        return { a, b, c };
      }
      function buildBoltGeom(curve, segments){
        const pts = new Float32Array((segments+1)*3);
        for(let i=0;i<=segments;i++){
          const t = i/segments;
          // Quadratic Bezier: (1-t)^2*A + 2(1-t)t*C + t^2*B
          const p = new THREE.Vector3().set(0,0,0)
            .addScaledVector(curve.a, (1-t)*(1-t))
            .addScaledVector(curve.c, 2*(1-t)*t)
            .addScaledVector(curve.b, t*t);
          pts[i*3+0]=p.x; pts[i*3+1]=p.y; pts[i*3+2]=p.z;
        }
        const g = new THREE.BufferGeometry(); g.setAttribute('position', new THREE.BufferAttribute(pts,3));
        return g;
      }
      function spawnBolt(){
        const curve = makeBoltCurve();
        const segs = 36 + Math.floor(Math.random()*22); // longer bolts
        const geom = buildBoltGeom(curve, segs);
        // Neon purple twin-lines (additive)
        const line = new THREE.Line(geom, new THREE.LineBasicMaterial({ color: 0xE55BFF, transparent:true, opacity:0.0, depthWrite:false, blending: THREE.AdditiveBlending }));
        const line2 = new THREE.Line(geom.clone(), new THREE.LineBasicMaterial({ color: 0xB388FF, transparent:true, opacity:0.0, depthWrite:false, blending: THREE.AdditiveBlending }));
        line2.scale.multiplyScalar(1.012);
        const g = new THREE.Group(); g.add(line); g.add(line2);
        // lifetime 0.22..0.55s
        g.userData.life = 0; g.userData.max = 220 + Math.floor(Math.random()*330);
        g.userData.dir = Math.random()<0.5 ? -1 : 1; // sway dir
        g.userData.jitter = ()=>{
          const pos = g.children[0].geometry.attributes.position; const cnt = pos.count;
          for(let i=0;i<cnt;i++){
            const jx = (Math.random()-0.5)*0.0045, jy = (Math.random()-0.5)*0.0045, jz = (Math.random()-0.5)*0.0045;
            pos.setXYZ(i, pos.getX(i)+jx, pos.getY(i)+jy, pos.getZ(i)+jz);
          }
          pos.needsUpdate = true;
          const pos2 = g.children[1].geometry.attributes.position; pos2.array.set(pos.array); pos2.needsUpdate = true;
        };
        bolts.add(g);
      }
      // Pre-spawn a few bolts
      for(let i=0;i<8;i++) spawnBolt();
      // Store reference for the animation loop
      grp.userData.bolts = bolts;
      grp.userData.spawn = spawnBolt;

      grp.position.y = -0.2 + MODEL_Y_OFFSET; // raised
      currentHead = grp; rig.add(grp);
      const sphere = new THREE.Sphere(new THREE.Vector3(), 1.2);
      const desired = sphere.radius / Math.tan((camera.fov * Math.PI/180) / 2) + 0.4;
      camera.position.z = Math.min(12, Math.max(2.2, desired));
      const hud = document.createElement('div');
      hud.style.cssText = 'position:fixed;left:16px;top:44px;background:#0b1f1d;border:1px solid #2b4946;color:#dff9f3;padding:8px 10px;border-radius:8px;z-index:10000;font:500 12px system-ui;opacity:.9';
      hud.textContent = 'Tesla Orb ready Â· Press 6 again to reload'; document.body.appendChild(hud);
      setTimeout(()=>hud.remove(), 2800);
      // Mark as Tesla for animation loop
      grp.userData.isTesla = true;
    }

    // Hotkeys to switch models quickly
    const MODELS = {
      // '1': '/glb/head.glb',
      // '2': '/glb/head2.glb',
      // '3': '/glb/head3.glb',
      '4': '/glb/head4.glb',
      // '5': '/glb/head5.glb',
      '6': '__TESLA__' // procedural abstract AI core (Tesla Orb)
    };
    window.addEventListener('keydown', (e)=>{
      const hit = MODELS[e.key];
      if(!hit) return;
      window.__LAST_MODEL_KEY = e.key;
      if(hit === '__TESLA__') loadTesla(); else loadHead(hit);
    });

    // Shift+R: reload current model bypassing cache
    window.addEventListener('keydown', (e)=>{
      if(e.key.toLowerCase()==='r' && e.shiftKey){
        // Determine which model was last loaded; default to '4'
        const last = (window.__LAST_MODEL_KEY || '4');
        __glbCacheToken = Date.now();
        const hit = MODELS[last];
        if(hit === '__TESLA__') loadTesla(); else loadHead(hit);
      }
    });

    // Auto-try head4 as default (others disabled)
    loadHead(MODELS['4']);

    // === Grounded neck pedestal (very subtle)
    const base = new THREE.Mesh(new THREE.CylinderGeometry(0.38, 0.48, 0.3, 48), new THREE.MeshBasicMaterial({ color: 0x0a2321, transparent:true, opacity:0.35}));
    base.position.y = -1.5 + MODEL_Y_OFFSET; // keep pedestal aligned after raising model
    rig.add(base);

    // === Ambient floating glitter
    const dust = new THREE.Group(); scene.add(dust);
    const dGeom = new THREE.BufferGeometry();
    const D = 400;
    const arr = new Float32Array(D*3);
    for(let i=0;i<D;i++){ arr[i*3+0]=(Math.random()-0.5)*5.0; arr[i*3+1]=Math.random()*3.0-0.5; arr[i*3+2]=(Math.random()-0.5)*3.0; }
    dGeom.setAttribute('position', new THREE.BufferAttribute(arr,3));
    const dMat = new THREE.PointsMaterial({ color:0xe9c46a, size:0.008, transparent:true, opacity:0.6 });
    const dPoints = new THREE.Points(dGeom, dMat); dust.add(dPoints);

    // === Interaction / Controls (drag look)
    let isDown=false, lx=0, ly=0, yaw=0, pitch=0, targetYaw=0, targetPitch=0;
    // Auto-look (head gently turns left/right on its own)
    let autoLook = true;            // toggle with 'A'
    let autoAmp = 0.28;             // amplitude in radians (~16Â°)
    let autoSpeed = 0.6;            // radians/sec factor for sine
    let lastInteract = 0;           // ms since last user input
    host.addEventListener('pointerdown', (e)=>{ isDown=true; lx=e.clientX; ly=e.clientY; lastInteract = performance.now(); });
    window.addEventListener('pointerup', ()=> { isDown=false; lastInteract = performance.now(); });
    window.addEventListener('pointermove', (e)=>{
      if(!isDown) return; const dx=(e.clientX-lx), dy=(e.clientY-ly); lx=e.clientX; ly=e.clientY;
      targetYaw += dx*0.0022; targetPitch += dy*0.0015; targetPitch = Math.max(-0.6, Math.min(0.6,targetPitch));
      lastInteract = performance.now();
    });

    // UI toggles and live visibility tuning
    window.addEventListener('keydown', (e)=>{
      const k = e.key;
      if(k.toLowerCase()==='g'){ uniforms.uGlow.value = uniforms.uGlow.value>0? 0.0:1.0; }
      if(k.toLowerCase()==='l'){ uniforms.uLineStrength.value = uniforms.uLineStrength.value>0? 0.0:0.95; }
      if(k.toLowerCase()==='s'){ uniforms.uScanOn.value = uniforms.uScanOn.value>0.5 ? 0.0 : 1.0; }
      if(k.toLowerCase()==='f'){ uniforms.uFlowOn.value = uniforms.uFlowOn.value>0.5 ? 0.0 : 1.0; }
      // Live tuning for visibility
      if(k==='['){ uniforms.uFlowDensity.value = Math.max(6.0, uniforms.uFlowDensity.value - 2.0); }
      if(k===']'){ uniforms.uFlowDensity.value = Math.min(96.0, uniforms.uFlowDensity.value + 2.0); }
      if(k===','){ uniforms.uGlyphSize.value = Math.max(0.06, uniforms.uGlyphSize.value - 0.02); }
      if(k==='.'){ uniforms.uGlyphSize.value = Math.min(0.50, uniforms.uGlyphSize.value + 0.02); }
      if(k==='-'){ uniforms.uFlowSpeed.value = Math.max(0.2, uniforms.uFlowSpeed.value - 0.2); }
      if(k==='='){ uniforms.uFlowSpeed.value = Math.min(6.0, uniforms.uFlowSpeed.value + 0.2); }
      if(k.toLowerCase()==='b'){ uniforms.uFlowBoost.value = (uniforms.uFlowBoost.value>1.6? 1.2: 2.2); }
      if(k.toLowerCase()==='c'){ uniforms.uFlowContrast.value = (uniforms.uFlowContrast.value>2.0? 1.6: 2.6); }
      if(k.toLowerCase()==='a'){ autoLook = !autoLook; }
      if(k==='ArrowUp'){ rig.position.y += 0.04; }
      if(k==='ArrowDown'){ rig.position.y -= 0.04; }
    });

    // Extra toggle: W = wireframe on/off (helps debugging visibility)
    window.addEventListener('keydown', (e)=>{
      if(e.key.toLowerCase()==='w'){
        rig.traverse((o)=>{
          if(o.isMesh && o.material){
            if('wireframe' in o.material){ o.material.wireframe = !o.material.wireframe; }
          }
        });
      }
    });

    // Mic toggle button wiring + hotkey (with toast + suspend/resume)
    const micBtn = document.getElementById('mic-toggle');
    function syncMicBtn(){ if(!micBtn) return; const on = !!MIC.enabled; micBtn.setAttribute('aria-pressed', on?'true':'false'); micBtn.title = on ? 'Disable mic' : 'Enable mic'; }
    async function enableMic(){
      MIC.enabled = true;
      if(MIC.ready){ try{ await MIC.ctx.resume(); }catch(_){} }
      if(!MIC.ready){ initMic(); }
      syncMicBtn(); micToast('Mic ON');
    }
    async function disableMic(){
      MIC.enabled = false;
      if(MIC.ready){ try{ await MIC.ctx.suspend(); }catch(_){} }
      MIC.level = 0; // hard reset level
      syncMicBtn(); micToast('Mic OFF');
    }
    if(micBtn && !micBtn.__wired){
      micBtn.__wired = true;
      micBtn.addEventListener('click', ()=>{ (MIC.enabled ? disableMic() : enableMic()); });
      syncMicBtn();
    }
    if(!window.__MIC_HOTKEY_WIRED__){
      window.__MIC_HOTKEY_WIRED__ = true;
      window.addEventListener('keydown', (e)=>{
        if(e.key.toLowerCase()==='m'){
          (MIC.enabled ? disableMic() : enableMic());
        }
      });
    }

    // Resize
    function onResize(){ const w=host.clientWidth, h=host.clientHeight; renderer.setSize(w,h); camera.aspect=w/h; camera.updateProjectionMatrix(); }
    window.addEventListener('resize', onResize);

    // Animate
    let t=0; function loop(){ requestAnimationFrame(loop); t+=0.016; uniforms.uTime.value = t; 
      // Mic sampling â†’ simple beat factor (respect toggle)
      let beat = 0.0;
      if(MIC.enabled && MIC.ready && MIC.analyser && MIC.data){
        MIC.analyser.getByteFrequencyData(MIC.data);
        let sum = 0, cnt = 0; const limit = Math.min(36, MIC.data.length);
        for(let i=2;i<limit;i++){ sum += MIC.data[i]; cnt++; }
        const avg = (cnt>0)? (sum/cnt) : 0;
        MIC.level = Math.max(0, Math.min(1, (avg - 32) / 80));
        beat = MIC.level;
      } else { MIC.level = 0; }
      // ease rig rotation to target
      yaw += (targetYaw - yaw)*0.08; 
      pitch += (targetPitch - pitch)*0.08;
      // Auto-look oscillation (only when not interacting recently)
      let autoYaw = 0.0;
      if(autoLook){
        const now = performance.now();
        const since = now - (lastInteract||0);
        // Fade in auto after ~0.8s of no interaction
        const fade = Math.max(0, Math.min(1, (since - 800) / 800));
        autoYaw = Math.sin(t * autoSpeed) * autoAmp * fade;
      }
      rig.rotation.y = yaw + autoYaw;
      rig.rotation.x = pitch;
      rig.position.y = Math.sin(t*0.6)*0.02;
      // animate shimmer points (if any)
      rig.traverse((o)=>{
        if(o.isPoints && o.userData._isShimmer){
          const pm = o.material; if(pm && pm.size !== undefined){ pm.size = 0.015 + 0.007*(1.0 + Math.sin(t*2.0)); }
        }
      });
      // Animate Tesla bolts if present
      if(currentHead && currentHead.userData && currentHead.userData.isTesla){
        const bolts = currentHead.userData.bolts;
        if(bolts){
          // target count & spawn rate scale with beat
          const target = 6 + Math.floor(6 * beat); // up to 12 bolts on peak
          const spawnProb = 0.04 + 0.22 * beat;    // more spawn when louder
          if(bolts.children.length < target && Math.random() < spawnProb){ currentHead.userData.spawn(); }
          for(let i=bolts.children.length-1;i>=0;i--){
            const g = bolts.children[i];
            g.userData.life++;
            const u = g.userData.life / g.userData.max; // 0..1
            // ease in/out opacity
            const ease = u < 0.5 ? (u*2.0) : (1.0 - (u-0.5)*2.0);
            const alpha = Math.max(0.0, Math.pow(ease, 0.6));
            const boost = 0.7 + 1.8 * beat; // brighter on beats
            g.children[0].material.opacity = 0.38 * alpha * boost;
            g.children[1].material.opacity = 0.26 * alpha * boost;
            // slight group sway
            g.rotation.z += 0.0025 * g.userData.dir;
            // crackle jitter
            if(Math.random()<0.35){ g.userData.jitter(); }
            // despawn
            if(g.userData.life >= g.userData.max){ bolts.remove(g); g.children.forEach(ch=>{ ch.geometry.dispose(); ch.material.dispose(); }); }
          }
        }
        // Animate inner arcs (core â†’ shell)
        const inner = currentHead.userData.inner;
        if(inner){
          const targetI = 10 + Math.floor(16 * beat); // many arcs on peaks
          const spawnProbI = 0.06 + 0.30 * beat;
          if(inner.children.length < targetI && Math.random() < spawnProbI){ currentHead.userData.spawnInner(); }
          for(let i=inner.children.length-1;i>=0;i--){
            const g = inner.children[i];
            g.userData.life++;
            const u = g.userData.life / g.userData.max;
            const ease = u < 0.5 ? (u*2.0) : (1.0 - (u-0.5)*2.0);
            const alpha = Math.max(0.0, Math.pow(ease, 0.6));
            const boost = 0.7 + 1.8 * beat;
            g.children[0].material.opacity = 0.40 * alpha * boost;
            g.children[1].material.opacity = 0.32 * alpha * boost;
            if(Math.random()<0.45){ g.userData.jitter(); }
            if(g.userData.life >= g.userData.max){ inner.remove(g); g.children.forEach(ch=>{ ch.geometry.dispose(); ch.material.dispose(); }); }
          }
        }
        // Core pulsing scale with beat
        currentHead.traverse((o)=>{
          if(o.userData && o.userData._isCore){
            const s = 0.38 * (1.0 + 0.25*beat + 0.05*Math.sin(t*6.0));
            o.scale.setScalar(Math.max(0.1, s));
          }
        });
      }
      // points twinkle
      dPoints.rotation.y += 0.0008; dPoints.rotation.x += 0.0003;
      camera.lookAt(rig.position);
      uniforms.uViewPos.value.copy(camera.position);
      renderer.render(scene,camera);
    } loop();
  })();
  </script>
</body>
  <script>
  (function(){
    const btn = document.getElementById('hint-toggle');
    if(!btn) return;
    const KEY = 'mm_show_hint_v1';
    // Restore last state
    const saved = localStorage.getItem(KEY);
    if(saved === '1') document.body.classList.add('show-hint');
    function sync(){
      const on = document.body.classList.contains('show-hint');
      btn.setAttribute('aria-pressed', on ? 'true' : 'false');
      btn.title = on ? 'Hide controls' : 'Show controls';
    }
    btn.addEventListener('click', ()=>{
      document.body.classList.toggle('show-hint');
      const on = document.body.classList.contains('show-hint');
      localStorage.setItem(KEY, on ? '1' : '0');
      sync();
    });
    // Ensure hidden by default when no saved preference
    sync();
  })();

  </script>
</html>

    