<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hologram Head – Ultra Real</title>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;background:#071312;color:#eafbf6;overflow:hidden}
    /* Premium backdrop */
    body{
      background:
        radial-gradient(1600px 720px at 50% -12%, #112c2a 0%, #0a1918 60%, #050c0b 100%),
        radial-gradient(600px 260px at 8% 10%, rgba(54,225,198,.08), transparent 65%),
        radial-gradient(800px 320px at 92% 88%, rgba(124,255,178,.06), transparent 70%);
    }
    #app{position:fixed; inset:0}
    canvas{display:block}
    /* UI hint */
    .hint{position:fixed; left:20px; bottom:18px; opacity:.65; font:500 12px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, 'Helvetica Neue', Arial}
    .hint kbd{padding:2px 6px; border:1px solid #2b4946; border-radius:6px; background:#0b1f1d; color:#dff9f3}
    /* === Legend HUD toggle (tiny) === */
    .hint{ display:none !important; }
    body.show-hint .hint{ display:block !important; }

    /* Tiny floating toggle button */
    .hint-toggle{
      position: fixed; left: 12px; bottom: 12px; z-index: 9999;
      width: 28px; height: 28px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,.28);
      background: linear-gradient(135deg, rgba(255,255,255,.14), rgba(255,255,255,.06));
      color: #dff9f3; font-weight: 700; font-size: 14px; line-height: 1;
      display: grid; place-items: center; cursor: pointer;
      box-shadow: 0 6px 16px rgba(0,0,0,.35);
    }
    .hint-toggle:hover{ transform: translateY(-1px); }
    .hint-toggle[aria-pressed="true"]{ border-color: rgba(124,255,178,.6); box-shadow: 0 0 0 1px rgba(124,255,178,.25) inset, 0 8px 20px rgba(124,255,178,.25); }
    @media (max-width: 768px){ .hint-toggle{ left: 10px; bottom: 10px; width: 26px; height: 26px; font-size: 13px; } }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="app"></div>
  <div class="hint">Drag = look · <kbd>G</kbd> glow · <kbd>L</kbd> lines · <kbd>S</kbd> scan · <kbd>F</kbd> flow · [ ] density · , . size · - = speed · <kbd>B</kbd>/<kbd>C</kbd> boost/contrast · <kbd>4</kbd> switch · <kbd>Shift+R</kbd> reload</div>
  <button id="hint-toggle" class="hint-toggle" aria-pressed="false" title="Show controls">?</button>

  <script type="module">
  import * as THREE from 'three';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
  // ==========================
  // Realistic Hologram Head (no external model):
  // - Lathe head geometry (stylized human head)
  // - Custom shader stripes + fresnel glow (horizontal lines like reference)
  // - Dynamic point cloud shimmer
  // - Subtle camera parallax and drag look
  // ==========================
  (function(){
    // Dev cache buster for GLB (browser caches aggressively)
    let __glbCacheToken = Date.now();
    function withCacheBust(url){
      const isLocal = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
      if(!isLocal) return url; // only bust on local dev
      const sep = url.includes('?') ? '&' : '?';
      return url + sep + 'v=' + (__glbCacheToken++);
    }
    const host = document.getElementById('app');
    const W = host.clientWidth, H = host.clientHeight, DPR = Math.min(2, window.devicePixelRatio||1);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(18, W/H, 0.1, 100); // tighter FOV for natural zoom-in
    camera.position.set(0, 0.18, 4.0);

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(DPR); renderer.setSize(W,H); renderer.setClearColor(0x000000, 0);
    host.appendChild(renderer.domElement);

    // Lighting is minimal; most look comes from shader emissive/fresnel
    const rig = new THREE.Group();
    scene.add(rig);

    // === Shader material for horizontal stripes + fresnel glow
    const uniforms = {
      uTime: { value: 0 },
      uColorA: { value: new THREE.Color(0x7cffb2) },
      uColorB: { value: new THREE.Color(0x36e1c6) },
      uStripeDensity: { value: 110.0 },   // number of lines along height
      uStripeSmooth: { value: 0.75 },     // softness of band edges
      uGlow: { value: 0.0 },
      uLineStrength: { value: 0.95 },
      uViewPos: { value: camera.position.clone() },
      uScanOn: { value: 1.0 },        // scan band on/off
      uScanWidth: { value: 0.19 },    // scan band width
      uScanSpeed: { value: 1.3 },     // scan speed
      uFlowOn: { value: 1.0 },      // surface-following hologram flow
      uFlowSpeed: { value: 1.4 },    // updated default
      uFlowDensity: { value: 14.0 }, // updated pulses across surface
      uGlyphSize: { value: 0.46 },   // thicker glyph stripes
      uFlowBoost: { value: 1.6 },    // brightness boost for flow
      uFlowContrast: { value: 2.2 }, // sharpen flow edges
    };

    const vert = `
      varying vec3 vPos; varying vec3 vNormal; varying vec3 vWorld; 
      void main(){
        vPos = position; vNormal = normalize(normalMatrix * normal);
        vec4 worldPos = modelMatrix * vec4(position,1.0); vWorld = worldPos.xyz;
        gl_Position = projectionMatrix * viewMatrix * worldPos;
      }
    `;

    // Simple hash noise
    const noise = `
      float hash12(vec2 p){ vec3 p3 = fract(vec3(p.xyx) * 0.1031);
        p3 += dot(p3, p3.yzx + 33.33); return fract((p3.x + p3.y) * p3.z);
      }
    `;

    const frag = `
  precision highp float; varying vec3 vPos; varying vec3 vNormal; varying vec3 vWorld;
  uniform float uTime; uniform vec3 uColorA; uniform vec3 uColorB;
  uniform float uStripeDensity; uniform float uStripeSmooth; uniform float uGlow; uniform float uLineStrength; uniform vec3 uViewPos;
  uniform float uScanOn; uniform float uScanWidth; uniform float uScanSpeed;
  uniform float uFlowOn; uniform float uFlowSpeed; uniform float uFlowDensity; uniform float uGlyphSize; uniform float uFlowBoost; uniform float uFlowContrast;

  float hash12(vec2 p){ vec3 p3 = fract(vec3(p.xyx) * 0.1031); p3 += dot(p3, p3.yzx + 33.33); return fract((p3.x + p3.y) * p3.z); }

  // TBN from screen-space derivatives to align effects to surface
  void makeTBN(in vec3 worldPos, out vec3 T, out vec3 B, out vec3 N){
    vec3 dpx = dFdx(worldPos); vec3 dpy = dFdy(worldPos);
    N = normalize(cross(dpx, dpy));
    vec3 ref = (abs(N.y) < 0.75) ? vec3(0.0,1.0,0.0) : vec3(1.0,0.0,0.0);
    T = normalize(ref - N * dot(ref, N));
    B = normalize(cross(N, T));
  }

  // Thin moving pulse pattern along 1D coordinate (returns 1 at line center)
  float pulse(float x, float width){
    float f = abs(fract(x) - 0.5);
    // steeper edge for high-contrast lines
    return 1.0 - smoothstep(0.5 - width, 0.5, f);
  }

  void main(){
    vec3 V = normalize(uViewPos - vWorld);
    vec3 T, B, N; makeTBN(vWorld, T, B, N);
    float fres = pow(1.0 - max(dot(normalize(N), V), 0.0), 2.0);

    // ===== Base dynamic horizontal stripes (background texture)
    float y = vWorld.y * uStripeDensity + uTime*12.0;
    float band = abs(fract(y) - 0.5);
    float stripes = smoothstep(0.45, 0.45 - uStripeSmooth*0.45, band);
    float n = hash12(vWorld.xz * 3.5 + uTime*0.05);
    float twinkle = 0.85 + 0.35 * sin(uTime*2.0 + vWorld.x*4.0 + vWorld.y*3.0);
    stripes = clamp(stripes * uLineStrength * mix(0.78, 1.22, n) * twinkle, 0.0, 1.0);

    // ===== Surface-aligned flowing glyphs (very visible)
    float u = dot(vWorld, T) * uFlowDensity + uTime * uFlowSpeed;
    float v = dot(vWorld, B) * uFlowDensity - uTime * (uFlowSpeed * 0.65);
    // Two interleaved lanes to look like "code"
    float flowU = pulse(u, uGlyphSize);
    float flowV = pulse(v + 0.33, uGlyphSize * 0.84);
    float flow = max(flowU, flowV) * uFlowOn;
    // Sharpen and boost
    flow = pow(clamp(flow, 0.0, 1.0), uFlowContrast);
    float flowGlow = smoothstep(0.0, 1.0, flow) * uFlowBoost;

    // ===== Optional scan band (kept subtle)
    float scanCenter = -1.2 + mod(uTime * uScanSpeed, 2.4);
    float d = abs(vWorld.y - scanCenter);
    float scanBand = (1.0 - smoothstep(uScanWidth, uScanWidth*1.8, d)) * uScanOn;

    // Compose color: stripes base
    vec3 base = mix(uColorB, uColorA, stripes);
    // Add bright cyan-violet flow tint so it pops
    vec3 flowTint = vec3(0.85, 1.00, 1.25);
    base += flowGlow * flowTint;

    // Rim and scan
    base += fres * uGlow * 0.85;
    base = mix(base, base * vec3(1.12,1.08,1.22), scanBand * 0.75);

    // Depth vignette
    float vignY = smoothstep(0.0, 0.6, abs(vWorld.y)*0.5);
    base *= mix(0.7, 1.0, 1.0 - vignY);

    // Make alpha react to flow so moving code is unmistakable
    float a = mix(0.82, 0.98, max(scanBand, flow*0.85));
    gl_FragColor = vec4(base, a);
  }
`;

    // === Fallback: procedural head (lathe) if GLB invalid (e.g., sphere)
    function createFallbackHead(){
      const pts = [];
      for(let i=0;i<=96;i++){
        const t = i/96;                 // 0..1 chin->crown
        const y = -1.22 + 2.44*t;       // total height ~2.44
        let r = 0.56 + 0.46*Math.sin(Math.PI*t);
        if(t<0.22) r *= 0.64 + 0.62*t;            // jaw+chin
        if(t>0.74) r *= 1.06 - 0.62*(t-0.74)/0.26;// forehead taper
        if(t<0.08) r *= 0.48;                      // neck
        pts.push(new THREE.Vector2(r, y));
      }
      const g = new THREE.LatheGeometry(pts, 320);
      g.rotateX(Math.PI*0.03);
      g.computeVertexNormals();
      const m = new THREE.ShaderMaterial({ uniforms, vertexShader: vert, fragmentShader: frag, transparent:true, depthWrite:false, depthTest:false, side: THREE.DoubleSide });
      const mesh = new THREE.Mesh(g, m);
      mesh.scale.set(0.92, 1.0, 1.06);
      return mesh;
    }

    // === Reusable GLB loader with auto-center/scale and fallback
    let currentHead = null;
    const loader = new GLTFLoader();
    // Shim: ignore legacy/unsupported material extensions (we override materials anyway)
    loader.register((parser)=>({ name: 'KHR_materials_pbrSpecularGlossiness' }));
    loader.register((parser)=>({ name: 'KHR_materials_common' }));

    function clearHead(){
      if(currentHead){ rig.remove(currentHead); currentHead.traverse?.(o=>{ if(o.geometry) o.geometry.dispose?.(); if(o.material){ if(o.material.map) o.material.map.dispose?.(); o.material.dispose?.(); }}); currentHead = null; }
    }

    function loadHead(url){
      clearHead();
      const badge = document.createElement('div');
      badge.style.cssText = 'position:fixed;left:16px;top:16px;background:#0b1f1d;border:1px solid #2b4946;color:#dff9f3;padding:8px 10px;border-radius:8px;z-index:10000;font:500 12px system-ui;opacity:.9';
      const finalURL = withCacheBust(url);
      badge.textContent = `Loading ${finalURL} ...`; document.body.appendChild(badge);

      loader.load(finalURL, (gltf)=>{
        const head = gltf.scene;
        let meshCount=0, skinnedCount=0;
        head.traverse((child)=>{
          if(child.isMesh || child.isSkinnedMesh){
            meshCount++; if(child.isSkinnedMesh) skinnedCount++;
            if(child.isSkinnedMesh){
              child.material = new THREE.MeshBasicMaterial({ color: 0x7cffb2, wireframe:true, transparent:true, opacity:0.9, side: THREE.DoubleSide, depthTest:false, depthWrite:false });
            } else {
              child.material = new THREE.ShaderMaterial({
                uniforms, vertexShader: vert, fragmentShader: frag,
                transparent:true, depthWrite:false, depthTest:false, side: THREE.DoubleSide
              });
            }
            child.castShadow = child.receiveShadow = false; child.frustumCulled=false; child.renderOrder=1;
          }
        });

        // Add a points shimmer overlay on top of each non-skinned mesh
        head.traverse((child)=>{
          if(child.isMesh && !child.isSkinnedMesh){
            const geo = child.geometry;
            const pts = new THREE.Points(
              geo,
              new THREE.PointsMaterial({ color: 0x7cffb2, size: 0.016, sizeAttenuation: true, transparent:true, opacity:0.9 })
            );
            // Match transform
            pts.position.copy(child.position); pts.rotation.copy(child.rotation); pts.scale.copy(child.scale);
            // Render after mesh
            pts.renderOrder = 2; pts.frustumCulled = false; pts.userData._isShimmer = true;
            child.add(pts);
          }
        });

        // Auto center/scale
        const preBox = new THREE.Box3().setFromObject(head);
        const size = new THREE.Vector3(); preBox.getSize(size);
        const center = new THREE.Vector3(); preBox.getCenter(center);
        head.position.sub(center);
        const targetH = 2.9; const s = (size.y>0.0001)? (targetH/size.y) : 1.0; head.scale.setScalar(s);
        const box = new THREE.Box3().setFromObject(head); const minY = box.min.y; head.position.y += (-1.2 - minY);

        // Sphere/placeholder detection (more lenient)
        const aspectXY = Math.abs(size.x - size.y) / Math.max(size.x, size.y);
        const aspectYZ = Math.abs(size.y - size.z) / Math.max(size.y, size.z);
        const isNearSphere = (aspectXY < 0.03) && (aspectYZ < 0.03);
        const likelySphereByName = (gltf.scene.name||'').toLowerCase().includes('sphere');
        if(isNearSphere || likelySphereByName || meshCount===0){
          const toast = document.createElement('div');
          toast.style.cssText = 'position:fixed;right:16px;top:16px;background:#3a1f1f;border:1px solid #a85d5d;color:#ffdede;padding:10px 12px;border-radius:8px;z-index:10000;font:500 12px system-ui';
          toast.textContent = `${finalURL} looks like a sphere/empty. Using procedural fallback.`; document.body.appendChild(toast); setTimeout(()=>toast.remove(), 4200);
          const fallback = createFallbackHead(); fallback.position.y = -0.2; currentHead=fallback; rig.add(fallback);
          badge.textContent = `Loaded: ${finalURL} → fallback (meshes: ${meshCount}${skinnedCount?` skinned:${skinnedCount}`:''})`;
          setTimeout(()=>badge.remove(), 3500);
          return;
        }

        // Face toward camera if needed + proportion tweak
        if(size.z > size.x * 1.2){ head.rotation.y = Math.PI; }
        head.scale.x *= 0.92; head.scale.z *= 1.06;

        currentHead = head; rig.add(head);
        // === Force-visible helpers & diagnostics
        // 1) Fit camera z based on bounding sphere (for safety)
        const sphere = new THREE.Sphere();
        new THREE.Box3().setFromObject(head).getBoundingSphere(sphere);
        if(isFinite(sphere.radius) && sphere.radius>0){
          const desired = sphere.radius / Math.tan((camera.fov * Math.PI/180) / 2) + 0.4; // smaller padding
          camera.position.z = Math.min(12, Math.max(2.2, desired * 0.9));
        }

        // 2) Show a Box3 helper briefly so we know where the model sits
        const helperBox = new THREE.Box3Helper(new THREE.Box3().setFromObject(head), 0x00ffcc);
        helperBox.material.transparent = true; helperBox.material.opacity = 0.25; helperBox.renderOrder = 10;
        rig.add(helperBox);
        setTimeout(()=>{ helperBox.visible = false; }, 4000);

        // 3) If somehow size is tiny, upscale again aggressively
        const finalBox = new THREE.Box3().setFromObject(head);
        const finalSize = new THREE.Vector3(); finalBox.getSize(finalSize);
        if(finalSize.y < 0.2){
          const boost = 0.2 / Math.max(1e-6, finalSize.y);
          head.scale.multiplyScalar(boost);
        }

        // 4) Persistent HUD (until next load) with final numbers
        const hud = document.createElement('div');
        hud.style.cssText = 'position:fixed;left:16px;top:44px;background:#0b1f1d;border:1px solid #2b4946;color:#dff9f3;padding:8px 10px;border-radius:8px;z-index:10000;font:500 12px system-ui;opacity:.9';
        hud.textContent = `Final bbox: ${finalSize.x.toFixed(2)} × ${finalSize.y.toFixed(2)} × ${finalSize.z.toFixed(2)} | camZ:${camera.position.z.toFixed(2)}`;
        document.body.appendChild(hud);
        setTimeout(()=>hud.remove(), 4500);
        badge.textContent = `Loaded: ${finalURL} ✓ meshes:${meshCount}${skinnedCount?` (skinned:${skinnedCount})`:''} sizeY:${size.y.toFixed(2)} → scale:${s.toFixed(3)}`;
        setTimeout(()=>badge.remove(), 3500);
      }, undefined, (err)=>{
        console.error('GLB load error', err);
        badge.textContent = `Failed to load ${finalURL}`; setTimeout(()=>badge.remove(), 4000);
        const msg = document.createElement('div');
        msg.style.cssText = 'position:fixed;right:16px;top:16px;background:#0b1f1d;border:1px solid #2b4946;color:#dff9f3;padding:10px 12px;border-radius:8px;z-index:10000;font:500 12px system-ui';
        msg.textContent = `Failed to load ${finalURL} – check path & server static config`;
        document.body.appendChild(msg); setTimeout(()=>msg.remove(), 5000);
      });
    }

    // Hotkeys to switch models quickly
    const MODELS = {
      // '1': '/glb/head.glb',
      // '2': '/glb/head2.glb',
      // '3': '/glb/head3.glb',
      '4': '/glb/head4.glb',
      // '5': '/glb/head5.glb'
    };
    window.addEventListener('keydown', (e)=>{
      if(MODELS[e.key]){ window.__LAST_MODEL_KEY = e.key; loadHead(MODELS[e.key]); }
    });

    // Shift+R: reload current model bypassing cache
    window.addEventListener('keydown', (e)=>{
      if(e.key.toLowerCase()==='r' && e.shiftKey){
        // Determine which model was last loaded; default to '4'
        const last = (window.__LAST_MODEL_KEY || '4');
        __glbCacheToken = Date.now();
        loadHead(MODELS[last]);
      }
    });

    // Auto-try head4 as default (others disabled)
    loadHead(MODELS['4']);

    // === Grounded neck pedestal (very subtle)
    const base = new THREE.Mesh(new THREE.CylinderGeometry(0.38, 0.48, 0.3, 48), new THREE.MeshBasicMaterial({ color: 0x0a2321, transparent:true, opacity:0.35}));
    base.position.y = -1.5; rig.add(base);

    // === Ambient floating glitter
    const dust = new THREE.Group(); scene.add(dust);
    const dGeom = new THREE.BufferGeometry();
    const D = 400;
    const arr = new Float32Array(D*3);
    for(let i=0;i<D;i++){ arr[i*3+0]=(Math.random()-0.5)*5.0; arr[i*3+1]=Math.random()*3.0-0.5; arr[i*3+2]=(Math.random()-0.5)*3.0; }
    dGeom.setAttribute('position', new THREE.BufferAttribute(arr,3));
    const dMat = new THREE.PointsMaterial({ color:0xe9c46a, size:0.008, transparent:true, opacity:0.6 });
    const dPoints = new THREE.Points(dGeom, dMat); dust.add(dPoints);

    // === Interaction / Controls (drag look)
    let isDown=false, lx=0, ly=0, yaw=0, pitch=0, targetYaw=0, targetPitch=0;
    host.addEventListener('pointerdown', (e)=>{ isDown=true; lx=e.clientX; ly=e.clientY;});
    window.addEventListener('pointerup', ()=> isDown=false);
    window.addEventListener('pointermove', (e)=>{
      if(!isDown) return; const dx=(e.clientX-lx), dy=(e.clientY-ly); lx=e.clientX; ly=e.clientY;
      targetYaw += dx*0.0022; targetPitch += dy*0.0015; targetPitch = Math.max(-0.6, Math.min(0.6,targetPitch));
    });

    // UI toggles and live visibility tuning
    window.addEventListener('keydown', (e)=>{
      const k = e.key;
      if(k.toLowerCase()==='g'){ uniforms.uGlow.value = uniforms.uGlow.value>0? 0.0:1.0; }
      if(k.toLowerCase()==='l'){ uniforms.uLineStrength.value = uniforms.uLineStrength.value>0? 0.0:0.95; }
      if(k.toLowerCase()==='s'){ uniforms.uScanOn.value = uniforms.uScanOn.value>0.5 ? 0.0 : 1.0; }
      if(k.toLowerCase()==='f'){ uniforms.uFlowOn.value = uniforms.uFlowOn.value>0.5 ? 0.0 : 1.0; }
      // Live tuning for visibility
      if(k==='['){ uniforms.uFlowDensity.value = Math.max(6.0, uniforms.uFlowDensity.value - 2.0); }
      if(k===']'){ uniforms.uFlowDensity.value = Math.min(96.0, uniforms.uFlowDensity.value + 2.0); }
      if(k===','){ uniforms.uGlyphSize.value = Math.max(0.06, uniforms.uGlyphSize.value - 0.02); }
      if(k==='.'){ uniforms.uGlyphSize.value = Math.min(0.50, uniforms.uGlyphSize.value + 0.02); }
      if(k==='-'){ uniforms.uFlowSpeed.value = Math.max(0.2, uniforms.uFlowSpeed.value - 0.2); }
      if(k==='='){ uniforms.uFlowSpeed.value = Math.min(6.0, uniforms.uFlowSpeed.value + 0.2); }
      if(k.toLowerCase()==='b'){ uniforms.uFlowBoost.value = (uniforms.uFlowBoost.value>1.6? 1.2: 2.2); }
      if(k.toLowerCase()==='c'){ uniforms.uFlowContrast.value = (uniforms.uFlowContrast.value>2.0? 1.6: 2.6); }
    });

    // Extra toggle: W = wireframe on/off (helps debugging visibility)
    window.addEventListener('keydown', (e)=>{
      if(e.key.toLowerCase()==='w'){
        rig.traverse((o)=>{
          if(o.isMesh && o.material){
            if('wireframe' in o.material){ o.material.wireframe = !o.material.wireframe; }
          }
        });
      }
    });

    // Resize
    function onResize(){ const w=host.clientWidth, h=host.clientHeight; renderer.setSize(w,h); camera.aspect=w/h; camera.updateProjectionMatrix(); }
    window.addEventListener('resize', onResize);

    // Animate
    let t=0; function loop(){ requestAnimationFrame(loop); t+=0.016; uniforms.uTime.value = t; 
      // ease rig rotation to target
      yaw += (targetYaw - yaw)*0.08; pitch += (targetPitch - pitch)*0.08;
      rig.rotation.y = yaw; rig.rotation.x = pitch; rig.position.y = Math.sin(t*0.6)*0.02;
      // animate shimmer points (if any)
      rig.traverse((o)=>{
        if(o.isPoints && o.userData._isShimmer){
          const pm = o.material; if(pm && pm.size !== undefined){ pm.size = 0.015 + 0.007*(1.0 + Math.sin(t*2.0)); }
        }
      });
      // points twinkle
      dPoints.rotation.y += 0.0008; dPoints.rotation.x += 0.0003;
      camera.lookAt(rig.position);
      uniforms.uViewPos.value.copy(camera.position);
      renderer.render(scene,camera);
    } loop();
  })();
  </script>
</body>
  <script>
  (function(){
    const btn = document.getElementById('hint-toggle');
    if(!btn) return;
    const KEY = 'mm_show_hint_v1';
    // Restore last state
    const saved = localStorage.getItem(KEY);
    if(saved === '1') document.body.classList.add('show-hint');
    function sync(){
      const on = document.body.classList.contains('show-hint');
      btn.setAttribute('aria-pressed', on ? 'true' : 'false');
      btn.title = on ? 'Hide controls' : 'Show controls';
    }
    btn.addEventListener('click', ()=>{
      document.body.classList.toggle('show-hint');
      const on = document.body.classList.contains('show-hint');
      localStorage.setItem(KEY, on ? '1' : '0');
      sync();
    });
    // Ensure hidden by default when no saved preference
    sync();
  })();
  </script>
</html>
